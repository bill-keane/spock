{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Managing complex configurations any other way would be highly illogical... About spock is a framework that helps manage complex parameter configurations during research and development of Python applications. spock let's you focus on the code you need to write instead of re-implementing boilerplate code like creating ArgParsers, reading configuration files, implementing traceability etc. In short, spock configurations are defined by simple and familiar class-based structures. This allows spock to support inheritance, read from multiple markdown formats, and allow hierarchical configuration by composition. Quick Install Supports Python 3.7+ pip install spock-config Documentation Current documentation and more information can be found here . Example spock usage is located here . Key Features Simple Declaration: Parameters are defined within a @spock_config decorated class. Supports types, required/optional, and automatic defaults. Easily Managed Parameter Groups: Each class automatically generates its own object within a single namespace. Parameter Inheritance: Classes support inheritance allowing for complex configurations derived from a common base set of parameters. Multiple Configuration File Types: Configurations are specified from YAML, TOML, or JSON files. Hierarchical Configuration: composed from multiple configuration files via simple include statements. Immutable: All classes are frozen preventing any misuse or accidental overwrites. Tractability and Reproducibility: Save currently running parameter configuration with a single chained command. Main Contributors Nicholas Cilfone , Siddharth Narayanan spock is developed and maintained by the Artificial Intelligence Center of Excellence at Fidelity Investments .","title":"Home"},{"location":"#about","text":"spock is a framework that helps manage complex parameter configurations during research and development of Python applications. spock let's you focus on the code you need to write instead of re-implementing boilerplate code like creating ArgParsers, reading configuration files, implementing traceability etc. In short, spock configurations are defined by simple and familiar class-based structures. This allows spock to support inheritance, read from multiple markdown formats, and allow hierarchical configuration by composition.","title":"About"},{"location":"#quick-install","text":"Supports Python 3.7+ pip install spock-config","title":"Quick Install"},{"location":"#documentation","text":"Current documentation and more information can be found here . Example spock usage is located here .","title":"Documentation"},{"location":"#key-features","text":"Simple Declaration: Parameters are defined within a @spock_config decorated class. Supports types, required/optional, and automatic defaults. Easily Managed Parameter Groups: Each class automatically generates its own object within a single namespace. Parameter Inheritance: Classes support inheritance allowing for complex configurations derived from a common base set of parameters. Multiple Configuration File Types: Configurations are specified from YAML, TOML, or JSON files. Hierarchical Configuration: composed from multiple configuration files via simple include statements. Immutable: All classes are frozen preventing any misuse or accidental overwrites. Tractability and Reproducibility: Save currently running parameter configuration with a single chained command.","title":"Key Features"},{"location":"#main-contributors","text":"Nicholas Cilfone , Siddharth Narayanan spock is developed and maintained by the Artificial Intelligence Center of Excellence at Fidelity Investments .","title":"Main Contributors"},{"location":"CHANGELOG/","text":"Spock CHANGELOG August 7th, 2020 - v1.0 Initial open source release June 18, 2020 - vPre-Release New Features: Added support for more config file types (TOML and JSON in additon to YAML) Added a new parameter type ChoiceArg for parameters that muse be chosen from a fixed set Additional unit test and linting Complete documentation overhaul with examples General code clean-up and doc-strings June 01, 2020 - vPreRelease New Features: Forked dataclass to remove order requirements for class inheritance General bug fixes, clean-up, and doc updates January 30, 2020 - vPreRelease New Features: Multiple configs with the same options Setting config specific options with YAML namespaces Python overrride/extension of YAML file path in ConfigArgBuilder with kwarg Removed: Ability to specify args at the command line (for now...) configargparse dependency January 6, 2020 - vPreRelease New Features: YAML inheritance -- composing from multiple YAML configuration files Additional unit tests Enhanced documentation October 15, 2019 - vPreRelease Initial release with all base functionality, documentation, and unit tests. September-October 2019 - vDev Dev period.","title":"Changelog"},{"location":"CHANGELOG/#spock-changelog","text":"","title":"Spock CHANGELOG"},{"location":"CHANGELOG/#august-7th-2020-v10","text":"Initial open source release","title":"August 7th, 2020 - v1.0"},{"location":"CHANGELOG/#june-18-2020-vpre-release","text":"New Features: Added support for more config file types (TOML and JSON in additon to YAML) Added a new parameter type ChoiceArg for parameters that muse be chosen from a fixed set Additional unit test and linting Complete documentation overhaul with examples General code clean-up and doc-strings","title":"June 18, 2020 - vPre-Release"},{"location":"CHANGELOG/#june-01-2020-vprerelease","text":"New Features: Forked dataclass to remove order requirements for class inheritance General bug fixes, clean-up, and doc updates","title":"June 01, 2020 - vPreRelease"},{"location":"CHANGELOG/#january-30-2020-vprerelease","text":"New Features: Multiple configs with the same options Setting config specific options with YAML namespaces Python overrride/extension of YAML file path in ConfigArgBuilder with kwarg Removed: Ability to specify args at the command line (for now...) configargparse dependency","title":"January 30, 2020 - vPreRelease"},{"location":"CHANGELOG/#january-6-2020-vprerelease","text":"New Features: YAML inheritance -- composing from multiple YAML configuration files Additional unit tests Enhanced documentation","title":"January 6, 2020 - vPreRelease"},{"location":"CHANGELOG/#october-15-2019-vprerelease","text":"Initial release with all base functionality, documentation, and unit tests.","title":"October 15, 2019 - vPreRelease"},{"location":"CHANGELOG/#september-october-2019-vdev","text":"Dev period.","title":"September-October 2019 - vDev"},{"location":"CONTRIBUTING/","text":"Contributing We welcome all contributions from the community! Any contributions to spock should come through valid Pull/Merge Requests in the public repository. Contribution Guidelines Adhere to PEP-8 standards. Any changes to core functionality must pass all existing unit tests. Additional functionality should have associated unit tests. Provide documentation (Google Docstring format) whenever possible, even for simple functions or classes.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"We welcome all contributions from the community! Any contributions to spock should come through valid Pull/Merge Requests in the public repository.","title":"Contributing"},{"location":"CONTRIBUTING/#contribution-guidelines","text":"Adhere to PEP-8 standards. Any changes to core functionality must pass all existing unit tests. Additional functionality should have associated unit tests. Provide documentation (Google Docstring format) whenever possible, even for simple functions or classes.","title":"Contribution Guidelines"},{"location":"docs/Installation/","text":"Installation Requirements Python: 3.7+ Dependencies: GitPython, PyYAML, toml Tested OS: Unix (Ubuntu 16.04, Ubuntu 18.04), OSX (10.14.6) Install/Upgrade Pip/PyPi pip install spock-config Pip From Source pip install git+https://github.com/fidelity/spock Build From Source git clone https://github.com/fidelity/spock cd spock pip install setuptools wheel python setup.py bdist_wheel pip install /dist/spock-config-X.X.XxX-py3-none-any.whl","title":"Installation"},{"location":"docs/Installation/#installation","text":"","title":"Installation"},{"location":"docs/Installation/#requirements","text":"Python: 3.7+ Dependencies: GitPython, PyYAML, toml Tested OS: Unix (Ubuntu 16.04, Ubuntu 18.04), OSX (10.14.6)","title":"Requirements"},{"location":"docs/Installation/#installupgrade","text":"","title":"Install/Upgrade"},{"location":"docs/Installation/#pippypi","text":"pip install spock-config","title":"Pip/PyPi"},{"location":"docs/Installation/#pip-from-source","text":"pip install git+https://github.com/fidelity/spock","title":"Pip From Source"},{"location":"docs/Installation/#build-from-source","text":"git clone https://github.com/fidelity/spock cd spock pip install setuptools wheel python setup.py bdist_wheel pip install /dist/spock-config-X.X.XxX-py3-none-any.whl","title":"Build From Source"},{"location":"docs/Motivation/","text":"Motivation Why Spock? spock arose out of a few observations within the Artificial Intelligence Center of Excellence at Fidelity. Modern ML Models == Spaghetti Parameters During research and development of machine learning (ML) models (especially deep learning models) the total number of configuration parameters within a codebase can quickly spiral out of control: data-related parameters, model hyper-parameters, logging parameters, i/o parameters, etc. After writing parser.add_argument() for the 1000th time we figured there had to be a better way to manage the complex configurations needed for modern ML models. In addition, we found a lot of open source ML/DL models (e.g. NVIDIA OpenSeq2Seq ) that had mind-boggling spaghetti parameter definitions. Just figuring out the configurations in order to run, modify, or re-implement an open-source model/library was becoming a minefield in and of itself. Finding a Consistent Solution Looking across an fast-moving enterprise scale AI organization, we noticed a pretty fractured set of configuration management practices across the organization (and even within groups). We saw some pretty bad practices like the hard-coding of parameters within scripts, functions, modules, ... e.g.: def my_function ( args ): my_parameter = 10 # do something with my_parameter ... Not only is this just bad practice but it is also not reproducible (your parameters become dependent on branch and commit) and really isn't helpful for a collaborative codebase. Additionally, it and makes monitoring, re-training, and/or deployment a nightmare. We saw a lot of colleagues taking an easy way out e.g.: ### in config.py ### PARAMETER_1 = 10 PARAMETER_2 = 'relu' ### in function.py ### from config import * def my_function ( arg_1 = PARAMETER_1 ): # do something with arg_1 ... Almost just as bad of practice as above but at least self-contained. It still is hard to reproduce and code and and parameters are still just as intertwined. Those who tried some configuration/parameter management resorted to re-implementing the same boilerplate code e.g.: import argparse parser = argparse . ArgumentParser () parser . add_argument ( '--foo' , help = 'foo help' ) args = parser . parse_args () Better practice to bring parameters in from the command line (or even an external INI file using configparser) but the amount of boilerplate is high and it's pretty tedious to manage more than 10+ parameters. On top of all of this, most parameter definitions were mutable meaning that they can be changed within code blocks (on purpose or by accident) leading to dangerous and unexpected behavior. What Does spock Do To Resolve These Observations? Thus, the idea of of spock was born... A simple, understandable, and lightweight library to manage complex parameter configurations during Python development. Anyone familiar with Python and knows how to define a basic class object can use spock (or if they don't there is plenty of documentation and tutorials on classes). Simple Declaration: Parameters are defined within a @spock_config decorated class. Supports types, required/optional, and automatic defaults. Easily Managed Parameter Groups: Each class automatically generates its own object within a single namespace. Parameter Inheritance: Classes support inheritance allowing for complex configurations derived from a common base set of parameters. Multiple Configuration File Types: Configurations are specified from YAML, TOML, or JSON files. Hierarchical Configuration: composed from multiple configuration files via simple include statements. Immutable: All classes are frozen preventing any misuse or accidental overwrites. Tractability and Reproducibility: Save currently running parameter configuration with a single chained command. Other Libraries There are other open source complex configuration libraries available for Python. We think that spock fits within this space by providing a simple and lightweight configuration management library in comparison to other libraries. The main two that fill a similar role as spock are: gin-config Provides a lightweight configuration framework for Python, based on dependency injection gin-config does a lot of things and does them pretty well. However, we found that gin-config 's dependency injection and heavy use of decorators just didn't fit what we wanted. Dynamic injection provides a less verbose configuration solution, but can lack reproducibility depending on where and how parameters are defined. In addition, the pretty large 'kitchen sink' of different ways to manage configurations isn't simple nor lightweight enough of a solution. Hydra A framework for elegantly configuring complex applications At the time we started building spock Hydra wasn't available. Hydra is similar to spock but is more restrictive in its functionality and syntax. Similar to gin-config parameters are dynamically injected via a decorator which limits type checking, reproducibility, and traceability. In addition, Hydra doesn't support inheritance which was a big motivator for creating a new solution.","title":"Motivation"},{"location":"docs/Motivation/#motivation","text":"","title":"Motivation"},{"location":"docs/Motivation/#why-spock","text":"spock arose out of a few observations within the Artificial Intelligence Center of Excellence at Fidelity.","title":"Why Spock?"},{"location":"docs/Motivation/#modern-ml-models-spaghetti-parameters","text":"During research and development of machine learning (ML) models (especially deep learning models) the total number of configuration parameters within a codebase can quickly spiral out of control: data-related parameters, model hyper-parameters, logging parameters, i/o parameters, etc. After writing parser.add_argument() for the 1000th time we figured there had to be a better way to manage the complex configurations needed for modern ML models. In addition, we found a lot of open source ML/DL models (e.g. NVIDIA OpenSeq2Seq ) that had mind-boggling spaghetti parameter definitions. Just figuring out the configurations in order to run, modify, or re-implement an open-source model/library was becoming a minefield in and of itself.","title":"Modern ML Models == Spaghetti Parameters"},{"location":"docs/Motivation/#finding-a-consistent-solution","text":"Looking across an fast-moving enterprise scale AI organization, we noticed a pretty fractured set of configuration management practices across the organization (and even within groups). We saw some pretty bad practices like the hard-coding of parameters within scripts, functions, modules, ... e.g.: def my_function ( args ): my_parameter = 10 # do something with my_parameter ... Not only is this just bad practice but it is also not reproducible (your parameters become dependent on branch and commit) and really isn't helpful for a collaborative codebase. Additionally, it and makes monitoring, re-training, and/or deployment a nightmare. We saw a lot of colleagues taking an easy way out e.g.: ### in config.py ### PARAMETER_1 = 10 PARAMETER_2 = 'relu' ### in function.py ### from config import * def my_function ( arg_1 = PARAMETER_1 ): # do something with arg_1 ... Almost just as bad of practice as above but at least self-contained. It still is hard to reproduce and code and and parameters are still just as intertwined. Those who tried some configuration/parameter management resorted to re-implementing the same boilerplate code e.g.: import argparse parser = argparse . ArgumentParser () parser . add_argument ( '--foo' , help = 'foo help' ) args = parser . parse_args () Better practice to bring parameters in from the command line (or even an external INI file using configparser) but the amount of boilerplate is high and it's pretty tedious to manage more than 10+ parameters. On top of all of this, most parameter definitions were mutable meaning that they can be changed within code blocks (on purpose or by accident) leading to dangerous and unexpected behavior.","title":"Finding a Consistent Solution"},{"location":"docs/Motivation/#what-does-spock-do-to-resolve-these-observations","text":"Thus, the idea of of spock was born... A simple, understandable, and lightweight library to manage complex parameter configurations during Python development. Anyone familiar with Python and knows how to define a basic class object can use spock (or if they don't there is plenty of documentation and tutorials on classes). Simple Declaration: Parameters are defined within a @spock_config decorated class. Supports types, required/optional, and automatic defaults. Easily Managed Parameter Groups: Each class automatically generates its own object within a single namespace. Parameter Inheritance: Classes support inheritance allowing for complex configurations derived from a common base set of parameters. Multiple Configuration File Types: Configurations are specified from YAML, TOML, or JSON files. Hierarchical Configuration: composed from multiple configuration files via simple include statements. Immutable: All classes are frozen preventing any misuse or accidental overwrites. Tractability and Reproducibility: Save currently running parameter configuration with a single chained command.","title":"What Does spock Do To Resolve These Observations?"},{"location":"docs/Motivation/#other-libraries","text":"There are other open source complex configuration libraries available for Python. We think that spock fits within this space by providing a simple and lightweight configuration management library in comparison to other libraries. The main two that fill a similar role as spock are:","title":"Other Libraries"},{"location":"docs/Motivation/#gin-config","text":"Provides a lightweight configuration framework for Python, based on dependency injection gin-config does a lot of things and does them pretty well. However, we found that gin-config 's dependency injection and heavy use of decorators just didn't fit what we wanted. Dynamic injection provides a less verbose configuration solution, but can lack reproducibility depending on where and how parameters are defined. In addition, the pretty large 'kitchen sink' of different ways to manage configurations isn't simple nor lightweight enough of a solution.","title":"gin-config"},{"location":"docs/Motivation/#hydra","text":"A framework for elegantly configuring complex applications At the time we started building spock Hydra wasn't available. Hydra is similar to spock but is more restrictive in its functionality and syntax. Similar to gin-config parameters are dynamically injected via a decorator which limits type checking, reproducibility, and traceability. In addition, Hydra doesn't support inheritance which was a big motivator for creating a new solution.","title":"Hydra"},{"location":"docs/Quick-Start/","text":"Quick Start This is a quick and dirty guide to getting up and running with spock . Read the Basic Tutorial as a simple guide and then explore more Advanced Features for in-depth usage. All examples can be found here . TL;DR Import the necessary components from spock Create a basic Python class, decorate it with @spock_config Define your parameters in the class Use the defined parameters in your code Create a configuration file Run your code with --config /path/to/config Simple Example A basic python script, simple.py . First we import the necessary functionality from spock . We define our class using the @spock_config decorator and our parameters with supported argument types from spock.args . from spock.args import * from spock.builder import ConfigArgBuilder from spock.config import spock_config @spock_config class BasicConfig : parameter : BoolArg fancy_parameter : FloatArg fancier_parameter : FloatArg most_fancy_parameter : ListArg [ int ] Next let's add two simple function(s) to our script. They both so the same thing but use our parameters in two different ways. def add_namespace ( config ): # Lets just do some basic algebra here val_sum = sum ([( config . fancy_parameter * val ) + config . fancier_parameter for val in config . most_fancy_parameter ]) # If the boolean is true let's round if config . parameter : val_sum = round ( val_sum ) return val_sum def add_by_parameter ( multiply_param , list_vals , add_param , tf_round ): # Lets just do some basic algebra here val_sum = sum ([( multiply_param * val ) + add_param for val in list_vals ]) # If the boolean is true let's round if tf_round : val_sum = round ( val_sum ) return val_sum Now, we build out the parameter objects by passing in the spock_config objects (as *args ) to the ConfigArgBuilder and chain call the generate method. The returned namespace object contains the dataclasses named with the spock_config class name. We then can pass the whole dataclass to our first function or specific parameters to our second function. def main (): # Chain the generate function to the class call config = ConfigArgBuilder ( BasicConfig ) . generate () # One can now access the Spock config object by class name with the returned namespace print ( config . BasicConfig . parameter ) # And pass the namespace to our first function val_sum_namespace = add_namespace ( config . BasicConfig ) print ( val_sum_namespace ) # Or pass by parameter val_sum_parameter = add_by_parameter ( config . BasicConfig . fancy_parameter , config . BasicConfig . most_fancy_parameter , config . BasicConfig . fancier_parameter , config . BasicConfig . parameter ) print ( val_sum_parameter ) if __name__ == '__main__' : main () Next let's create a simple configuration file that sets the values of our parameters. Let's make a YAML file (you can also use TOML or JSON), simple.yaml : # Parameters parameter : true fancy_parameter : 8.8 fancier_parameter : 64.64 most_fancy_parameter : [ 768 , 768 , 512 , 128 ] Finally, we would then pass the path to the configuration file to the command line (-c or --config): $ python simple.py -c simple.yaml","title":"Quick Start"},{"location":"docs/Quick-Start/#quick-start","text":"This is a quick and dirty guide to getting up and running with spock . Read the Basic Tutorial as a simple guide and then explore more Advanced Features for in-depth usage. All examples can be found here .","title":"Quick Start"},{"location":"docs/Quick-Start/#tldr","text":"Import the necessary components from spock Create a basic Python class, decorate it with @spock_config Define your parameters in the class Use the defined parameters in your code Create a configuration file Run your code with --config /path/to/config","title":"TL;DR"},{"location":"docs/Quick-Start/#simple-example","text":"A basic python script, simple.py . First we import the necessary functionality from spock . We define our class using the @spock_config decorator and our parameters with supported argument types from spock.args . from spock.args import * from spock.builder import ConfigArgBuilder from spock.config import spock_config @spock_config class BasicConfig : parameter : BoolArg fancy_parameter : FloatArg fancier_parameter : FloatArg most_fancy_parameter : ListArg [ int ] Next let's add two simple function(s) to our script. They both so the same thing but use our parameters in two different ways. def add_namespace ( config ): # Lets just do some basic algebra here val_sum = sum ([( config . fancy_parameter * val ) + config . fancier_parameter for val in config . most_fancy_parameter ]) # If the boolean is true let's round if config . parameter : val_sum = round ( val_sum ) return val_sum def add_by_parameter ( multiply_param , list_vals , add_param , tf_round ): # Lets just do some basic algebra here val_sum = sum ([( multiply_param * val ) + add_param for val in list_vals ]) # If the boolean is true let's round if tf_round : val_sum = round ( val_sum ) return val_sum Now, we build out the parameter objects by passing in the spock_config objects (as *args ) to the ConfigArgBuilder and chain call the generate method. The returned namespace object contains the dataclasses named with the spock_config class name. We then can pass the whole dataclass to our first function or specific parameters to our second function. def main (): # Chain the generate function to the class call config = ConfigArgBuilder ( BasicConfig ) . generate () # One can now access the Spock config object by class name with the returned namespace print ( config . BasicConfig . parameter ) # And pass the namespace to our first function val_sum_namespace = add_namespace ( config . BasicConfig ) print ( val_sum_namespace ) # Or pass by parameter val_sum_parameter = add_by_parameter ( config . BasicConfig . fancy_parameter , config . BasicConfig . most_fancy_parameter , config . BasicConfig . fancier_parameter , config . BasicConfig . parameter ) print ( val_sum_parameter ) if __name__ == '__main__' : main () Next let's create a simple configuration file that sets the values of our parameters. Let's make a YAML file (you can also use TOML or JSON), simple.yaml : # Parameters parameter : true fancy_parameter : 8.8 fancier_parameter : 64.64 most_fancy_parameter : [ 768 , 768 , 512 , 128 ] Finally, we would then pass the path to the configuration file to the command line (-c or --config): $ python simple.py -c simple.yaml","title":"Simple Example"},{"location":"docs/advanced_features/About/","text":"Advanced Features This series of pages walks you through most of the advanced features spock provides. At the end you should understand the additional functionality that spock provides and be able to use these advanced features within your own code. The example used in the Advanced Features series of pages can be found here .","title":"About"},{"location":"docs/advanced_features/About/#advanced-features","text":"This series of pages walks you through most of the advanced features spock provides. At the end you should understand the additional functionality that spock provides and be able to use these advanced features within your own code. The example used in the Advanced Features series of pages can be found here .","title":"Advanced Features"},{"location":"docs/advanced_features/Composition/","text":"Composing Configuration Files spock supports hierarchical composition of configuration files with a simple syntax. Composing Two YAML Files Going back to our example. Let's say we had a a portion of our configuration that does not change that often while another portion changes frequently or are parameters that are being experimented with. For instance, let's say we have finalized things related to our data set (although in our examples it is random... let's just imagine for now) but we are still experimenting with our neural network parameters. Instead of maintaining multiple copies of configuration files where parameters related to the data set are not changing, we can compose two separate configuration files together. One static file related to the data set parameters and a more dynamic file that is changing. This separation helps keep errors from propagating into the static set of data set related parameters. For instance we can break our tutorial.yaml file into two. First, let's split out the static data related parameters into: data.yaml ################ # data.yaml ################ # DataConfig batch_size : 2 n_samples : 8 DataConfig : cache_path : /home/user/cache/ And then in our second configuration file we can use the config: key to define the other configuration files we want to compose into this configuration file: changing.yaml ################ # changing.yaml ################ # Global cache_path : /tmp/cache/ config : [ /data.yaml ] # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 # SGD Config weight_decay : 1E-5 momentum : 0.9 nesterov : true Warning You can add as many configuration files as you want to a config tag however be aware of circular dependencies (we do not check for these yet) and that the lower a configuration file is in the order (i.e. later in the list) that it will take precedence over the others.","title":"Composition"},{"location":"docs/advanced_features/Composition/#composing-configuration-files","text":"spock supports hierarchical composition of configuration files with a simple syntax.","title":"Composing Configuration Files"},{"location":"docs/advanced_features/Composition/#composing-two-yaml-files","text":"Going back to our example. Let's say we had a a portion of our configuration that does not change that often while another portion changes frequently or are parameters that are being experimented with. For instance, let's say we have finalized things related to our data set (although in our examples it is random... let's just imagine for now) but we are still experimenting with our neural network parameters. Instead of maintaining multiple copies of configuration files where parameters related to the data set are not changing, we can compose two separate configuration files together. One static file related to the data set parameters and a more dynamic file that is changing. This separation helps keep errors from propagating into the static set of data set related parameters. For instance we can break our tutorial.yaml file into two. First, let's split out the static data related parameters into: data.yaml ################ # data.yaml ################ # DataConfig batch_size : 2 n_samples : 8 DataConfig : cache_path : /home/user/cache/ And then in our second configuration file we can use the config: key to define the other configuration files we want to compose into this configuration file: changing.yaml ################ # changing.yaml ################ # Global cache_path : /tmp/cache/ config : [ /data.yaml ] # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 # SGD Config weight_decay : 1E-5 momentum : 0.9 nesterov : true","title":"Composing Two YAML Files"},{"location":"docs/advanced_features/Composition/#warning","text":"You can add as many configuration files as you want to a config tag however be aware of circular dependencies (we do not check for these yet) and that the lower a configuration file is in the order (i.e. later in the list) that it will take precedence over the others.","title":"Warning"},{"location":"docs/advanced_features/Defaults/","text":"Defaults spock allows you to set defaults for parameters that are either not set from a configuration file or you no longer need to set (maybe you've finally settled on a standard or would like to fall back to defaults if the user does not know the correct/best parameter to choose). This is done in the spock class definition. Setting Defaults Say we want defaults for the hidden layer sizes and the activation function as well as add a new parameter with a default value. For basic types ( FloatArg , IntArg , StrArg , BoolArg ) default values are set with the = operator. For ListArg and TupleArg types, defaults are set using the .defualt() method. For ChoiceArg the default value is set using the default keyword arg. Let's modify the definition in: tutorial.py from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : save_path : SavePathOptArg lr : FloatArg = 0.01 n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) We added a new parameter lr that has a default value of 0.01 , and set defaults for hidden_sizes and activation . These values will be used if no values are specified in the configuration file and prevent spock from raising an exception for required parameters.","title":"Default Values"},{"location":"docs/advanced_features/Defaults/#defaults","text":"spock allows you to set defaults for parameters that are either not set from a configuration file or you no longer need to set (maybe you've finally settled on a standard or would like to fall back to defaults if the user does not know the correct/best parameter to choose). This is done in the spock class definition.","title":"Defaults"},{"location":"docs/advanced_features/Defaults/#setting-defaults","text":"Say we want defaults for the hidden layer sizes and the activation function as well as add a new parameter with a default value. For basic types ( FloatArg , IntArg , StrArg , BoolArg ) default values are set with the = operator. For ListArg and TupleArg types, defaults are set using the .defualt() method. For ChoiceArg the default value is set using the default keyword arg. Let's modify the definition in: tutorial.py from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : save_path : SavePathOptArg lr : FloatArg = 0.01 n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) We added a new parameter lr that has a default value of 0.01 , and set defaults for hidden_sizes and activation . These values will be used if no values are specified in the configuration file and prevent spock from raising an exception for required parameters.","title":"Setting Defaults"},{"location":"docs/advanced_features/Inheritance/","text":"Inheritance spock supports class inheritance between different defined spock classes. This allows you to build complex configurations derived from a common base class or classes. Defining an Inherited spock Class Back to our example. We have implemented two different optimizers to train our neural network. In its current state we have overlooked the fact that the two different optimizers share a set of common parameters but each also has a set of specific parameters. Instead of defining redundant parameter definitions let's use spock inheritance. We create a new spock class that inherits from another spock class. This functions just like traditional inheritance where the child will inherit the parameter definitions from the parent class. Editing our definition in: tutorial.py from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : save_path : SavePathOptArg n_features : IntArg dropout : ListOptArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) optimizer = ChoiceArg ( choice_set = [ 'SGD' , 'Adam' ]) @spock_config class DataConfig : batch_size : IntArg = 2 n_samples : IntArg = 8 @spock_config class OptimizerConfig : lr : FloatArg = 0.01 n_epochs : IntArg = 2 grad_clip : FloatOptArg @spock_config class SGDConfig ( OptimizerConfig ): weight_decay : FloatArg momentum : FloatArg nesterov : BoolArg Editing our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # DataConfig batch_size : 2 n_samples : 8 # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 # SGD Config weight_decay : 1E-5 momentum : 0.9 nesterov : true Using an Inherited spock Class Let's use our inherited class to use the SGD optimizer with the defined parameter on our basic neural network: tutorial.py import torch from .basic_nn import BasicNet def train ( x_data , y_data , model , model_config , data_config , optimizer_config ): if model_config . optimizer == 'SGD' : optimizer = torch . optim . SGD ( model . parameters (), lr = optimizer_config . lr , momentum = optimizer_config . momentum , nesterov = optimizer_config . nesterov ) elif model_config . optimizer == 'Adam' : optimizer = torch . optim . Adam ( model . parameters (), lr = optimizer_config . lr ) else : raise ValueError ( f 'Optimizer choice {optimizer_config.optimizer} not available' ) n_steps_per_epoch = data_config . n_samples % data_config . batch_size for epoch in range ( optimizer_config . n_epochs ): for i in range ( n_steps_per_epoch ): # Ugly data slicing for simplicity x_batch = x_data [ i * n_steps_per_epoch :( i + 1 ) * n_steps_per_epoch , ] y_batch = y_data [ i * n_steps_per_epoch :( i + 1 ) * n_steps_per_epoch , ] optimizer . zero_grad () output = model ( x_batch ) loss = torch . nn . CrossEntropyLoss ( output , y_batch ) loss . backward () if optimizer_config . grad_clip : torch . nn . utils . clip_grad_value ( model . parameters (), optimizer_config . grad_clip ) optimizer . step () print ( f 'Finished Epoch {epoch+1}' ) def main (): # A simple description description = 'spock Advanced Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , DataConfig , SGDConfig , desc = description ) . generate () # Instantiate our neural net using basic_nn = BasicNet ( model_config = config . ModelConfig ) # Make some random data (BxH): H has dim of features in x_data = torch . rand ( config . DataConfig . n_samples , config . ModelConfig . n_features ) y_data = torch . randint ( 0 , 3 , ( config . DataConfig . n_samples ,)) # Run some training train ( x_data , y_data , basic_nn , config . ModelConfig , config . DataConfig , config . SGDConfig )","title":"Inheritance"},{"location":"docs/advanced_features/Inheritance/#inheritance","text":"spock supports class inheritance between different defined spock classes. This allows you to build complex configurations derived from a common base class or classes.","title":"Inheritance"},{"location":"docs/advanced_features/Inheritance/#defining-an-inherited-spock-class","text":"Back to our example. We have implemented two different optimizers to train our neural network. In its current state we have overlooked the fact that the two different optimizers share a set of common parameters but each also has a set of specific parameters. Instead of defining redundant parameter definitions let's use spock inheritance. We create a new spock class that inherits from another spock class. This functions just like traditional inheritance where the child will inherit the parameter definitions from the parent class. Editing our definition in: tutorial.py from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : save_path : SavePathOptArg n_features : IntArg dropout : ListOptArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) optimizer = ChoiceArg ( choice_set = [ 'SGD' , 'Adam' ]) @spock_config class DataConfig : batch_size : IntArg = 2 n_samples : IntArg = 8 @spock_config class OptimizerConfig : lr : FloatArg = 0.01 n_epochs : IntArg = 2 grad_clip : FloatOptArg @spock_config class SGDConfig ( OptimizerConfig ): weight_decay : FloatArg momentum : FloatArg nesterov : BoolArg Editing our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # DataConfig batch_size : 2 n_samples : 8 # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 # SGD Config weight_decay : 1E-5 momentum : 0.9 nesterov : true","title":"Defining an Inherited spock Class"},{"location":"docs/advanced_features/Inheritance/#using-an-inherited-spock-class","text":"Let's use our inherited class to use the SGD optimizer with the defined parameter on our basic neural network: tutorial.py import torch from .basic_nn import BasicNet def train ( x_data , y_data , model , model_config , data_config , optimizer_config ): if model_config . optimizer == 'SGD' : optimizer = torch . optim . SGD ( model . parameters (), lr = optimizer_config . lr , momentum = optimizer_config . momentum , nesterov = optimizer_config . nesterov ) elif model_config . optimizer == 'Adam' : optimizer = torch . optim . Adam ( model . parameters (), lr = optimizer_config . lr ) else : raise ValueError ( f 'Optimizer choice {optimizer_config.optimizer} not available' ) n_steps_per_epoch = data_config . n_samples % data_config . batch_size for epoch in range ( optimizer_config . n_epochs ): for i in range ( n_steps_per_epoch ): # Ugly data slicing for simplicity x_batch = x_data [ i * n_steps_per_epoch :( i + 1 ) * n_steps_per_epoch , ] y_batch = y_data [ i * n_steps_per_epoch :( i + 1 ) * n_steps_per_epoch , ] optimizer . zero_grad () output = model ( x_batch ) loss = torch . nn . CrossEntropyLoss ( output , y_batch ) loss . backward () if optimizer_config . grad_clip : torch . nn . utils . clip_grad_value ( model . parameters (), optimizer_config . grad_clip ) optimizer . step () print ( f 'Finished Epoch {epoch+1}' ) def main (): # A simple description description = 'spock Advanced Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , DataConfig , SGDConfig , desc = description ) . generate () # Instantiate our neural net using basic_nn = BasicNet ( model_config = config . ModelConfig ) # Make some random data (BxH): H has dim of features in x_data = torch . rand ( config . DataConfig . n_samples , config . ModelConfig . n_features ) y_data = torch . randint ( 0 , 3 , ( config . DataConfig . n_samples ,)) # Run some training train ( x_data , y_data , basic_nn , config . ModelConfig , config . DataConfig , config . SGDConfig )","title":"Using an Inherited spock Class"},{"location":"docs/advanced_features/Local-Overrides/","text":"Local Overrides The class based solution within spock provides the ability to override a global parameter value within a local class context. Overriding a Global Value Let's define two new parameters with the same name but in two different classes that represent where some stuff is going to be cached. One for the model and one for some data. Editing our definition in: tutorial.py from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : save_path : SavePathOptArg n_features : IntArg dropout : ListOptArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) optimizer = ChoiceArg ( choice_set = [ 'SGD' , 'Adam' ]) cache_path : StrOptArg @spock_config class DataConfig : batch_size : IntArg = 2 n_samples : IntArg = 8 cache_path : StrOptArg @spock_config class OptimizerConfig : lr : FloatArg = 0.01 n_epochs : IntArg = 2 grad_clip : FloatOptArg @spock_config class SGDConfig ( OptimizerConfig ): weight_decay : FloatArg momentum : FloatArg nesterov : BoolArg Now, if we edit our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Global cache_path : /tmp/cache/ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # DataConfig batch_size : 2 n_samples : 8 # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 # SGD Config weight_decay : 1E-5 momentum : 0.9 nesterov : true This configuration file would set both parameters to use the /tmp/cache/ value (i.e. it would set the parameter value globally). But what if we want to the data cache to be a different path? We can override the global parameter value with a local parameter value. Editing our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Global cache_path : /tmp/cache/ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] n_hidden : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # DataConfig batch_size : 2 n_samples : 8 DataConfig : cache_path : /home/user/cache/ # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 # SGD Config weight_decay : 1E-5 momentum : 0.9 nesterov : true","title":"Local Overrides"},{"location":"docs/advanced_features/Local-Overrides/#local-overrides","text":"The class based solution within spock provides the ability to override a global parameter value within a local class context.","title":"Local Overrides"},{"location":"docs/advanced_features/Local-Overrides/#overriding-a-global-value","text":"Let's define two new parameters with the same name but in two different classes that represent where some stuff is going to be cached. One for the model and one for some data. Editing our definition in: tutorial.py from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : save_path : SavePathOptArg n_features : IntArg dropout : ListOptArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) optimizer = ChoiceArg ( choice_set = [ 'SGD' , 'Adam' ]) cache_path : StrOptArg @spock_config class DataConfig : batch_size : IntArg = 2 n_samples : IntArg = 8 cache_path : StrOptArg @spock_config class OptimizerConfig : lr : FloatArg = 0.01 n_epochs : IntArg = 2 grad_clip : FloatOptArg @spock_config class SGDConfig ( OptimizerConfig ): weight_decay : FloatArg momentum : FloatArg nesterov : BoolArg Now, if we edit our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Global cache_path : /tmp/cache/ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # DataConfig batch_size : 2 n_samples : 8 # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 # SGD Config weight_decay : 1E-5 momentum : 0.9 nesterov : true This configuration file would set both parameters to use the /tmp/cache/ value (i.e. it would set the parameter value globally). But what if we want to the data cache to be a different path? We can override the global parameter value with a local parameter value. Editing our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Global cache_path : /tmp/cache/ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] n_hidden : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # DataConfig batch_size : 2 n_samples : 8 DataConfig : cache_path : /home/user/cache/ # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 # SGD Config weight_decay : 1E-5 momentum : 0.9 nesterov : true","title":"Overriding a Global Value"},{"location":"docs/advanced_features/Optional-Parameters/","text":"Optional Parameters spock allows for parameters to be defined as optional. This means that if the parameter value is not set from either a configuration file or a default value it will be assigned the None value. Optional spock parameters are defined using the optional version of the base type: FloatOptArg , IntOptArg , StrOptArg , ListOptArg , TupleOptArg . Defining Optional spock Parameters Optional parameters commonly occur in applications with complex behavior (like neural networks). For instance, what if you want to execute a specific behavior with some parameter(s) if the parameter is defined and if the parameter is not defined either skip the behavior or so something different. Normally this would require a combination of boolean logic and parameter definition (which might be useless...). spock remedies this with optional parameters. As an example, let's assume we want to make dropout within our basic neural network optional. Let's modify the definition in: tutorial.py @spock_config class ModelConfig : save_path : SavePathOptArg lr : FloatArg = 0.01 n_features : IntArg dropout : ListOptArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) Notice that all we did was change the type from ListArg to ListOptAg . Now let's edit our simple neural network code to reflect that dropout is now optional. We have to change the code a bit to be more modular (but still ugly for demonstration): basic_nn.py import torch.nn as nn class BasicNet ( nn . Module ): def __init__ ( self , model_config ): super ( BasicNet , self ) . __init__ () # Make a dictionary of activation functions to select from self . act_fncs = { 'relu' : nn . ReLU , 'gelu' : nn . GELU , 'tanh' : nn . Tanh } self . use_act = self . act_fncs . get ( model_config . activation )() # Define the layers manually (avoiding list comprehension for clarity) self . layer_1 = nn . Linear ( model_config . n_features , model_config . hidden_sizes [ 0 ]) self . layer_2 = nn . Linear ( model_config . hidden_sizes [ 0 ], model_config . hidden_sizes [ 1 ]) self . layer_3 = nn . Linear ( model_config . hidden_sizes [ 1 ], model_config . hidden_sizes [ 2 ]) # Define some dropout layers self . dropout = [] if model_config . dropout is not None : self . dropout = [ nn . Dropout ( val ) for val in model_config . dropout ] # Define the output layer self . softmax = nn . Softmax ( dim = 1 ) def forward ( self , x ): # x is the data input # Layer 1 # Linear x = self . layer_1 ( x ) # Activation x = self . use_act ( x ) # Dropout if len ( self . dropout ) != 0 : x = self . dropout [ 0 ]( x ) # Layer 2 # Linear x = self . layer_2 ( x ) # Activation x = self . use_act ( x ) # Dropout if len ( self . dropout ) != 0 : x = self . dropout [ 1 ]( x ) # Layer 3 # Linear x = self . layer_3 ( x ) # Softmax output = self . softmax ( x ) return output Code Behavior If we use the same configuration file defined in: tutorial.yaml ################ # tutorial.yaml ################ # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu With this configuration file, the parameter dropout is assigned the specified value. Thus our basic neural network will have dropout layers between Layer 1, Layer 2, and Layer 3. However, if we use the following configuration file: tutorial_no_dropout.yaml ################ # tutorial.yaml ################ # ModelConfig n_features : 64 hidden_sizes : [ 32 , 32 , 16 ] activation : relu With this configuration file, the parameter dropout is assigned None . Thus our based on the logic in our code our basic neural network will not have dropout between layers. This simple example demonstrates the power of spock optional parameters. Flow through code can easily be modified by simply changing the configuration file.","title":"Optional Parameters"},{"location":"docs/advanced_features/Optional-Parameters/#optional-parameters","text":"spock allows for parameters to be defined as optional. This means that if the parameter value is not set from either a configuration file or a default value it will be assigned the None value. Optional spock parameters are defined using the optional version of the base type: FloatOptArg , IntOptArg , StrOptArg , ListOptArg , TupleOptArg .","title":"Optional Parameters"},{"location":"docs/advanced_features/Optional-Parameters/#defining-optional-spock-parameters","text":"Optional parameters commonly occur in applications with complex behavior (like neural networks). For instance, what if you want to execute a specific behavior with some parameter(s) if the parameter is defined and if the parameter is not defined either skip the behavior or so something different. Normally this would require a combination of boolean logic and parameter definition (which might be useless...). spock remedies this with optional parameters. As an example, let's assume we want to make dropout within our basic neural network optional. Let's modify the definition in: tutorial.py @spock_config class ModelConfig : save_path : SavePathOptArg lr : FloatArg = 0.01 n_features : IntArg dropout : ListOptArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) Notice that all we did was change the type from ListArg to ListOptAg . Now let's edit our simple neural network code to reflect that dropout is now optional. We have to change the code a bit to be more modular (but still ugly for demonstration): basic_nn.py import torch.nn as nn class BasicNet ( nn . Module ): def __init__ ( self , model_config ): super ( BasicNet , self ) . __init__ () # Make a dictionary of activation functions to select from self . act_fncs = { 'relu' : nn . ReLU , 'gelu' : nn . GELU , 'tanh' : nn . Tanh } self . use_act = self . act_fncs . get ( model_config . activation )() # Define the layers manually (avoiding list comprehension for clarity) self . layer_1 = nn . Linear ( model_config . n_features , model_config . hidden_sizes [ 0 ]) self . layer_2 = nn . Linear ( model_config . hidden_sizes [ 0 ], model_config . hidden_sizes [ 1 ]) self . layer_3 = nn . Linear ( model_config . hidden_sizes [ 1 ], model_config . hidden_sizes [ 2 ]) # Define some dropout layers self . dropout = [] if model_config . dropout is not None : self . dropout = [ nn . Dropout ( val ) for val in model_config . dropout ] # Define the output layer self . softmax = nn . Softmax ( dim = 1 ) def forward ( self , x ): # x is the data input # Layer 1 # Linear x = self . layer_1 ( x ) # Activation x = self . use_act ( x ) # Dropout if len ( self . dropout ) != 0 : x = self . dropout [ 0 ]( x ) # Layer 2 # Linear x = self . layer_2 ( x ) # Activation x = self . use_act ( x ) # Dropout if len ( self . dropout ) != 0 : x = self . dropout [ 1 ]( x ) # Layer 3 # Linear x = self . layer_3 ( x ) # Softmax output = self . softmax ( x ) return output","title":"Defining Optional spock Parameters"},{"location":"docs/advanced_features/Optional-Parameters/#code-behavior","text":"If we use the same configuration file defined in: tutorial.yaml ################ # tutorial.yaml ################ # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu With this configuration file, the parameter dropout is assigned the specified value. Thus our basic neural network will have dropout layers between Layer 1, Layer 2, and Layer 3. However, if we use the following configuration file: tutorial_no_dropout.yaml ################ # tutorial.yaml ################ # ModelConfig n_features : 64 hidden_sizes : [ 32 , 32 , 16 ] activation : relu With this configuration file, the parameter dropout is assigned None . Thus our based on the logic in our code our basic neural network will not have dropout between layers. This simple example demonstrates the power of spock optional parameters. Flow through code can easily be modified by simply changing the configuration file.","title":"Code Behavior"},{"location":"docs/advanced_features/Parameter-Groups/","text":"Parameter Groups Since spock manages complex configurations via a class based solution we can define and decorate multiple classes with @spock_config . Each class gets created as a separate class object within the spock namespace object. Building spock Parameter Groups Let's go back to our example. Say we need to add a few more parameters to our code. We could just keep adding them to the single defined class, but this would lead to a 'mega' class that has parameters for many different parts of your code. Instead, we will define two new spock classes for our new parameters and begin to organize them by functionality. Editing our definition in: tutorial.py from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : save_path : SavePathOptArg n_features : IntArg dropout : ListOptArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) optimizer = ChoiceArg ( choice_set = [ 'SGD' , 'Adam' ]) @spock_config class DataConfig : batch_size : IntArg = 2 n_samples : IntArg = 8 @spock_config class OptimizerConfig : lr : FloatArg = 0.01 n_epochs : IntArg = 2 grad_clip : FloatOptArg Now we have three separate spock classes that we need to generate the namespace object from. Simply add the new classes to *args in the ConfigArgBuilder . Editing tutorial.py : from spock.builder import ConfigArgBuilder def main (): # A simple description description = 'spock Advanced Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , DataConfig , OptimizerConfig , desc = description ) . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig ) print ( config . OptimizerConfig ) Editing our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # DataConfig batch_size : 2 n_samples : 8 # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0 Adding More Code Let's add a bit more functionality to our code that uses our new parameters by running a 'basic training loop' (this is kept very simple for illustrative purposes, hence the simple data slicing) on our basic neural network: tutorial.py import torch from .basic_nn import BasicNet def train ( x_data , y_data , model , model_config , data_config , optimizer_config ): if model_config . optimizer == 'SGD' : optimizer = torch . optim . SGD ( model . parameters (), lr = optimizer_config . lr ) elif model_config . optimizer == 'Adam' : optimizer = torch . optim . Adam ( model . parameters (), lr = optimizer_config . lr ) else : raise ValueError ( f 'Optimizer choice {optimizer_config.optimizer} not available' ) n_steps_per_epoch = data_config . n_samples % data_config . batch_size for epoch in range ( optimizer_config . n_epochs ): for i in range ( n_steps_per_epoch ): # Ugly data slicing for simplicity x_batch = x_data [ i * n_steps_per_epoch :( i + 1 ) * n_steps_per_epoch ,] y_batch = y_data [ i * n_steps_per_epoch :( i + 1 ) * n_steps_per_epoch ,] optimizer . zero_grad () output = model ( x_batch ) loss = torch . nn . CrossEntropyLoss ( output , y_batch ) loss . backward () if optimizer_config . grad_clip : torch . nn . utils . clip_grad_value ( model . parameters (), optimizer_config . grad_clip ) optimizer . step () def main (): # A simple description description = 'spock Advanced Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , DataConfig , OptimizerConfig , desc = description ) . generate () # Instantiate our neural net using basic_nn = BasicNet ( model_config = config . ModelConfig ) # Make some random data (BxH): H has dim of features in x_data = torch . rand ( config . DataConfig . n_samples , config . ModelConfig . n_features ) y_data = torch . randint ( 0 , 3 , ( config . DataConig . n_samples ,)) # Run some training train ( x_data , y_data , basic_nn , config . ModelConfig , config . DataConfig , config . OptimizerConfig )","title":"Parameter Groups"},{"location":"docs/advanced_features/Parameter-Groups/#parameter-groups","text":"Since spock manages complex configurations via a class based solution we can define and decorate multiple classes with @spock_config . Each class gets created as a separate class object within the spock namespace object.","title":"Parameter Groups"},{"location":"docs/advanced_features/Parameter-Groups/#building-spock-parameter-groups","text":"Let's go back to our example. Say we need to add a few more parameters to our code. We could just keep adding them to the single defined class, but this would lead to a 'mega' class that has parameters for many different parts of your code. Instead, we will define two new spock classes for our new parameters and begin to organize them by functionality. Editing our definition in: tutorial.py from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : save_path : SavePathOptArg n_features : IntArg dropout : ListOptArg [ float ] hidden_sizes : TupleArg [ int ] = TupleArg . defaults (( 32 , 32 , 32 )) activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ], default = 'relu' ) optimizer = ChoiceArg ( choice_set = [ 'SGD' , 'Adam' ]) @spock_config class DataConfig : batch_size : IntArg = 2 n_samples : IntArg = 8 @spock_config class OptimizerConfig : lr : FloatArg = 0.01 n_epochs : IntArg = 2 grad_clip : FloatOptArg Now we have three separate spock classes that we need to generate the namespace object from. Simply add the new classes to *args in the ConfigArgBuilder . Editing tutorial.py : from spock.builder import ConfigArgBuilder def main (): # A simple description description = 'spock Advanced Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , DataConfig , OptimizerConfig , desc = description ) . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig ) print ( config . OptimizerConfig ) Editing our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu optimizer : SGD # DataConfig batch_size : 2 n_samples : 8 # OptimizerConfig lr : 0.01 n_epochs : 2 grad_clip : 5.0","title":"Building spock Parameter Groups"},{"location":"docs/advanced_features/Parameter-Groups/#adding-more-code","text":"Let's add a bit more functionality to our code that uses our new parameters by running a 'basic training loop' (this is kept very simple for illustrative purposes, hence the simple data slicing) on our basic neural network: tutorial.py import torch from .basic_nn import BasicNet def train ( x_data , y_data , model , model_config , data_config , optimizer_config ): if model_config . optimizer == 'SGD' : optimizer = torch . optim . SGD ( model . parameters (), lr = optimizer_config . lr ) elif model_config . optimizer == 'Adam' : optimizer = torch . optim . Adam ( model . parameters (), lr = optimizer_config . lr ) else : raise ValueError ( f 'Optimizer choice {optimizer_config.optimizer} not available' ) n_steps_per_epoch = data_config . n_samples % data_config . batch_size for epoch in range ( optimizer_config . n_epochs ): for i in range ( n_steps_per_epoch ): # Ugly data slicing for simplicity x_batch = x_data [ i * n_steps_per_epoch :( i + 1 ) * n_steps_per_epoch ,] y_batch = y_data [ i * n_steps_per_epoch :( i + 1 ) * n_steps_per_epoch ,] optimizer . zero_grad () output = model ( x_batch ) loss = torch . nn . CrossEntropyLoss ( output , y_batch ) loss . backward () if optimizer_config . grad_clip : torch . nn . utils . clip_grad_value ( model . parameters (), optimizer_config . grad_clip ) optimizer . step () def main (): # A simple description description = 'spock Advanced Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , DataConfig , OptimizerConfig , desc = description ) . generate () # Instantiate our neural net using basic_nn = BasicNet ( model_config = config . ModelConfig ) # Make some random data (BxH): H has dim of features in x_data = torch . rand ( config . DataConfig . n_samples , config . ModelConfig . n_features ) y_data = torch . randint ( 0 , 3 , ( config . DataConig . n_samples ,)) # Run some training train ( x_data , y_data , basic_nn , config . ModelConfig , config . DataConfig , config . OptimizerConfig )","title":"Adding More Code"},{"location":"docs/basic_tutorial/About/","text":"Basic Tutorial This series of pages will walk you through the basics of spock . At the end you should understand the basic functionality that spock provides and be able to use the core functional units within your own code. The example used in the Basic tutorial series of pages can be found here .","title":"About"},{"location":"docs/basic_tutorial/About/#basic-tutorial","text":"This series of pages will walk you through the basics of spock . At the end you should understand the basic functionality that spock provides and be able to use the core functional units within your own code. The example used in the Basic tutorial series of pages can be found here .","title":"Basic Tutorial"},{"location":"docs/basic_tutorial/Building/","text":"Build Once all of the parameters we need have been defined in our spock class and we've written some code to use those parameters we need to generate the namespace object. The namespace object is the heart of spock and is how one accesses all of the defined parameters. The generation of the namespace should happen at the highest level of code, preferably in the main guard protected call or main function call. This allows the namespace object, the spock classes, or the individual parameters to be passed to lower level functionality. Generate the spock Namespace Object So let's continue in: tutorial.py Recall that we defined our spock class as such: @spock_config class ModelConfig : n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ]) To generate the namespace object, import the ConfigArgBuilder class, pass in your @spock_config classes as *args , add an optional description, and then chain call the generate() method. Each spock class is defined in the namespace object given by the class name. from spock.builder import ConfigArgBuilder def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description ) . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig ) if __name__ == '__main__' : main () Using spock Parameters Our simple neural network code referenced some spock defined parameters. So let's link them together correctly and test our model. We will pass the full spock class from the generated namespace object to our nn.module class. Continuing in: tutorial.py import torch from .basic_nn import BasicNet def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description ) . generate () # Instantiate our neural net using basic_nn = BasicNet ( model_config = config . ModelConfig ) # Make some random data (BxH): H has dim of features in test_data = torch . rand ( 10 , config . ModelConfig . n_features ) result = basic_nn ( test_data ) print ( result )","title":"Building"},{"location":"docs/basic_tutorial/Building/#build","text":"Once all of the parameters we need have been defined in our spock class and we've written some code to use those parameters we need to generate the namespace object. The namespace object is the heart of spock and is how one accesses all of the defined parameters. The generation of the namespace should happen at the highest level of code, preferably in the main guard protected call or main function call. This allows the namespace object, the spock classes, or the individual parameters to be passed to lower level functionality.","title":"Build"},{"location":"docs/basic_tutorial/Building/#generate-the-spock-namespace-object","text":"So let's continue in: tutorial.py Recall that we defined our spock class as such: @spock_config class ModelConfig : n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ]) To generate the namespace object, import the ConfigArgBuilder class, pass in your @spock_config classes as *args , add an optional description, and then chain call the generate() method. Each spock class is defined in the namespace object given by the class name. from spock.builder import ConfigArgBuilder def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description ) . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig ) if __name__ == '__main__' : main ()","title":"Generate the spock Namespace Object"},{"location":"docs/basic_tutorial/Building/#using-spock-parameters","text":"Our simple neural network code referenced some spock defined parameters. So let's link them together correctly and test our model. We will pass the full spock class from the generated namespace object to our nn.module class. Continuing in: tutorial.py import torch from .basic_nn import BasicNet def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description ) . generate () # Instantiate our neural net using basic_nn = BasicNet ( model_config = config . ModelConfig ) # Make some random data (BxH): H has dim of features in test_data = torch . rand ( 10 , config . ModelConfig . n_features ) result = basic_nn ( test_data ) print ( result )","title":"Using spock Parameters"},{"location":"docs/basic_tutorial/Configuration-Files/","text":"Configuration Files Values in spock are set using external configuration files. Supported Configuration Formats YAML Requires file extension of .yaml . Supported using the external PyYAML library. TOML Requires file extension of .toml . Supported using the external toml library. JSON Requires file extension of .json . Supported using the built-in json module. Creating a Configuration File Recall that we defined our spock class as such: @spock_config class ModelConfig : n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ]) Note that all of the types of our parameters IntArg , ListArg , TupleArg , and ChoiceArg are required types. This means that if we do not specify values for these parameters in our configuration file spock will throw an exception. Let's create our configuration file using the YAML standard: tutorial.yaml ################ # tutorial.yaml ################ # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu","title":"Configuration Files"},{"location":"docs/basic_tutorial/Configuration-Files/#configuration-files","text":"Values in spock are set using external configuration files.","title":"Configuration Files"},{"location":"docs/basic_tutorial/Configuration-Files/#supported-configuration-formats","text":"","title":"Supported Configuration Formats"},{"location":"docs/basic_tutorial/Configuration-Files/#yaml","text":"Requires file extension of .yaml . Supported using the external PyYAML library.","title":"YAML"},{"location":"docs/basic_tutorial/Configuration-Files/#toml","text":"Requires file extension of .toml . Supported using the external toml library.","title":"TOML"},{"location":"docs/basic_tutorial/Configuration-Files/#json","text":"Requires file extension of .json . Supported using the built-in json module.","title":"JSON"},{"location":"docs/basic_tutorial/Configuration-Files/#creating-a-configuration-file","text":"Recall that we defined our spock class as such: @spock_config class ModelConfig : n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ]) Note that all of the types of our parameters IntArg , ListArg , TupleArg , and ChoiceArg are required types. This means that if we do not specify values for these parameters in our configuration file spock will throw an exception. Let's create our configuration file using the YAML standard: tutorial.yaml ################ # tutorial.yaml ################ # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu","title":"Creating a Configuration File"},{"location":"docs/basic_tutorial/Define/","text":"Define spock manages complex configurations via a class based solution. All parameters are defined in a class or multiple classes decorated with @spock_config . Parameters are defined with spock types that are checked at run time. Once built, all parameters can be found within an automatically generated namespace object that contains each class that can be accessed with the spock_config class name. All examples can be found here . Supported Parameter Types spock supports the following argument types: Python Base Type spock Type Optional spock Type Description bool BoolArg N/A Basic boolean parameter (e.g. True) float FloatArg FloatOptArg Basic float type parameter (e.g. 10.2) int IntArg IntOptArg Basic integer type parameter (e.g. 2) str StrArg StrOptArg Basic string type parameter (e.g. 'foo') list ListArg ListOptArg Basic list type parameter of base types such as int, float, etc. (e.g. [10.0, 2.0]) tuple TupleArg TupleOptArg Basic tuple type parameter of base types such as int, float, etc. (e.g. (10, 2)) N/A ChoiceArg N/A Parameter that must be from a defined set of values of base types such as int, float, etc. Defining A spock Class Let's start building out an example (a simple neural net in PyTorch) that we will continue to use within the tutorial: tutorial.py Here we import the basic units of functionality from spock . We define our class using the @spock_config decorator and define our parameters with supported argument types from spock.args . Parameters are defined within the class by using the format parameter: type . from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ]) Using spock Parameters: Writing More Code In another file let's write our simple neural network code: basic_nn.py Notice that even before we've built and linked all of the related spock components together we are referencing the parameters we have defined in our spock class. Below we are passing in the ModelConfig class as a parameter model_config to the __init__ function where we can then access the parameters with . notation. We could have also passed in individual parameters instead if that is the preferred syntax. import torch.nn as nn class BasicNet ( nn . Module ): def __init__ ( self , model_config ): super ( BasicNet , self ) . __init__ () # Make a dictionary of activation functions to select from self . act_fncs = { 'relu' : nn . ReLU , 'gelu' : nn . GELU , 'tanh' : nn . Tanh } self . use_act = self . act_fncs . get ( model_config . activation )() # Define the layers manually (avoiding list comprehension for clarity) self . layer_1 = nn . Linear ( model_config . n_features , model_config . hidden_sizes [ 0 ]) self . layer_2 = nn . Linear ( model_config . hidden_sizes [ 0 ], model_config . hidden_sizes [ 1 ]) self . layer_3 = nn . Linear ( model_config . hidden_sizes [ 1 ], model_config . hidden_sizes [ 2 ]) # Define some dropout layers self . dropout_1 = nn . Dropout ( model_config . dropout [ 0 ]) self . dropout_2 = nn . Dropout ( model_config . dropout [ 1 ]) # Define the output layer self . softmax = nn . Softmax ( dim = 1 ) def forward ( self , x ): # x is the data input # Layer 1 # Linear x = self . layer_1 ( x ) # Activation x = self . use_act ( x ) # Dropout x = self . dropout_1 ( x ) # Layer 2 # Linear x = self . layer_2 ( x ) # Activation x = self . use_act ( x ) # Dropout x = self . dropout_2 ( x ) # Layer 3 # Linear x = self . layer_3 ( x ) # Softmax output = self . softmax ( x ) return output","title":"Define"},{"location":"docs/basic_tutorial/Define/#define","text":"spock manages complex configurations via a class based solution. All parameters are defined in a class or multiple classes decorated with @spock_config . Parameters are defined with spock types that are checked at run time. Once built, all parameters can be found within an automatically generated namespace object that contains each class that can be accessed with the spock_config class name. All examples can be found here .","title":"Define"},{"location":"docs/basic_tutorial/Define/#supported-parameter-types","text":"spock supports the following argument types: Python Base Type spock Type Optional spock Type Description bool BoolArg N/A Basic boolean parameter (e.g. True) float FloatArg FloatOptArg Basic float type parameter (e.g. 10.2) int IntArg IntOptArg Basic integer type parameter (e.g. 2) str StrArg StrOptArg Basic string type parameter (e.g. 'foo') list ListArg ListOptArg Basic list type parameter of base types such as int, float, etc. (e.g. [10.0, 2.0]) tuple TupleArg TupleOptArg Basic tuple type parameter of base types such as int, float, etc. (e.g. (10, 2)) N/A ChoiceArg N/A Parameter that must be from a defined set of values of base types such as int, float, etc.","title":"Supported Parameter Types"},{"location":"docs/basic_tutorial/Define/#defining-a-spock-class","text":"Let's start building out an example (a simple neural net in PyTorch) that we will continue to use within the tutorial: tutorial.py Here we import the basic units of functionality from spock . We define our class using the @spock_config decorator and define our parameters with supported argument types from spock.args . Parameters are defined within the class by using the format parameter: type . from spock.args import * from spock.config import spock_config @spock_config class ModelConfig : n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ])","title":"Defining A spock Class"},{"location":"docs/basic_tutorial/Define/#using-spock-parameters-writing-more-code","text":"In another file let's write our simple neural network code: basic_nn.py Notice that even before we've built and linked all of the related spock components together we are referencing the parameters we have defined in our spock class. Below we are passing in the ModelConfig class as a parameter model_config to the __init__ function where we can then access the parameters with . notation. We could have also passed in individual parameters instead if that is the preferred syntax. import torch.nn as nn class BasicNet ( nn . Module ): def __init__ ( self , model_config ): super ( BasicNet , self ) . __init__ () # Make a dictionary of activation functions to select from self . act_fncs = { 'relu' : nn . ReLU , 'gelu' : nn . GELU , 'tanh' : nn . Tanh } self . use_act = self . act_fncs . get ( model_config . activation )() # Define the layers manually (avoiding list comprehension for clarity) self . layer_1 = nn . Linear ( model_config . n_features , model_config . hidden_sizes [ 0 ]) self . layer_2 = nn . Linear ( model_config . hidden_sizes [ 0 ], model_config . hidden_sizes [ 1 ]) self . layer_3 = nn . Linear ( model_config . hidden_sizes [ 1 ], model_config . hidden_sizes [ 2 ]) # Define some dropout layers self . dropout_1 = nn . Dropout ( model_config . dropout [ 0 ]) self . dropout_2 = nn . Dropout ( model_config . dropout [ 1 ]) # Define the output layer self . softmax = nn . Softmax ( dim = 1 ) def forward ( self , x ): # x is the data input # Layer 1 # Linear x = self . layer_1 ( x ) # Activation x = self . use_act ( x ) # Dropout x = self . dropout_1 ( x ) # Layer 2 # Linear x = self . layer_2 ( x ) # Activation x = self . use_act ( x ) # Dropout x = self . dropout_2 ( x ) # Layer 3 # Linear x = self . layer_3 ( x ) # Softmax output = self . softmax ( x ) return output","title":"Using spock Parameters: Writing More Code"},{"location":"docs/basic_tutorial/Run/","text":"Run In summary, we have constructed the four basic pieces of spock . A spock class that defines our parameters (Basics) Generated the spock namespace object (Building) Referenced spock parameters in other code (Building) Created a configuration file (Configuration Files) Now we can run our basic neural network example. Running Our Code To run tutorial.py we pass the path to the configuration file as a command line argument: $ python tutorial.py --config tutorial.yaml The complete basic example can be found here .","title":"Running"},{"location":"docs/basic_tutorial/Run/#run","text":"In summary, we have constructed the four basic pieces of spock . A spock class that defines our parameters (Basics) Generated the spock namespace object (Building) Referenced spock parameters in other code (Building) Created a configuration file (Configuration Files) Now we can run our basic neural network example.","title":"Run"},{"location":"docs/basic_tutorial/Run/#running-our-code","text":"To run tutorial.py we pass the path to the configuration file as a command line argument: $ python tutorial.py --config tutorial.yaml The complete basic example can be found here .","title":"Running Our Code"},{"location":"docs/basic_tutorial/Saving/","text":"Saving The current configuration of running python code can be saved to file by chaining the save() method before the generate() call to the ConfigArgBuilder class. spock supports two ways to specify the path to write and the output file can be either YAML, TOML, or JSON (via the file_extension keyword argument). Specify spock Special Parameter Type We simply specify a SavePathOptArg in a spock config, which is a special argument type that is used to set the save path from a configuration file. Adding to: tutorial.py @spock_config class ModelConfig : save_path : SavePathOptArg n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ]) And adding in the chained save() call... def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description ) . save ( file_extension = '.toml' ) . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig ) Adding the output path to our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu Specify Path In-Line Here we simply specify the path when calling the save() method. In: tutorial.yaml def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description ) . save ( user_specified_path = '/tmp' ) . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig ) Does the Directory Exit In either case, if the save path does not exist, it will not be created by default. To change this behavior, set create_save_path when creating the builder. In: tutorial.py def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description , create_save_path = True ) . save () . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig )","title":"Saving"},{"location":"docs/basic_tutorial/Saving/#saving","text":"The current configuration of running python code can be saved to file by chaining the save() method before the generate() call to the ConfigArgBuilder class. spock supports two ways to specify the path to write and the output file can be either YAML, TOML, or JSON (via the file_extension keyword argument).","title":"Saving"},{"location":"docs/basic_tutorial/Saving/#specify-spock-special-parameter-type","text":"We simply specify a SavePathOptArg in a spock config, which is a special argument type that is used to set the save path from a configuration file. Adding to: tutorial.py @spock_config class ModelConfig : save_path : SavePathOptArg n_features : IntArg dropout : ListArg [ float ] hidden_sizes : TupleArg [ int ] activation : ChoiceArg ( choice_set = [ 'relu' , 'gelu' , 'tanh' ]) And adding in the chained save() call... def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description ) . save ( file_extension = '.toml' ) . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig ) Adding the output path to our configuration file: tutorial.yaml ################ # tutorial.yaml ################ # Special Key save_path : /tmp # ModelConfig n_features : 64 dropout : [ 0.2 , 0.1 ] hidden_sizes : [ 32 , 32 , 16 ] activation : relu","title":"Specify spock Special Parameter Type"},{"location":"docs/basic_tutorial/Saving/#specify-path-in-line","text":"Here we simply specify the path when calling the save() method. In: tutorial.yaml def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description ) . save ( user_specified_path = '/tmp' ) . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig )","title":"Specify Path In-Line"},{"location":"docs/basic_tutorial/Saving/#does-the-directory-exit","text":"In either case, if the save path does not exist, it will not be created by default. To change this behavior, set create_save_path when creating the builder. In: tutorial.py def main (): # A simple description description = 'spock Tutorial' # Build out the parser by passing in Spock config objects as *args after description config = ConfigArgBuilder ( ModelConfig , desc = description , create_save_path = True ) . save () . generate () # One can now access the Spock config object by class name with the returned namespace # For instance... print ( config . ModelConfig )","title":"Does the Directory Exit"},{"location":"reference/spock/","text":"Module spock Spock is a framework that helps manage complex parameter configurations for Python applications Please refer to the documentation provided in the README.md View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\" Spock is a framework that helps manage complex parameter configurations for Python applications Please refer to the documentation provided in the README.md \"\"\" __all__ = [ \"args\" , \"builder\" , \"config\" ] from ._version import get_versions __version__ = get_versions ()[ 'version' ] del get_versions Sub-modules spock.args spock.builder spock.config spock.handlers spock.payload spock.saver spock.utils","title":"Index"},{"location":"reference/spock/#module-spock","text":"Spock is a framework that helps manage complex parameter configurations for Python applications Please refer to the documentation provided in the README.md View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\" Spock is a framework that helps manage complex parameter configurations for Python applications Please refer to the documentation provided in the README.md \"\"\" __all__ = [ \"args\" , \"builder\" , \"config\" ] from ._version import get_versions __version__ = get_versions ()[ 'version' ] del get_versions","title":"Module spock"},{"location":"reference/spock/#sub-modules","text":"spock.args spock.builder spock.config spock.handlers spock.payload spock.saver spock.utils","title":"Sub-modules"},{"location":"reference/spock/args/","text":"Module spock.args Handles the definitions of arguments types for Spock View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Handles the definitions of arguments types for Spock\"\"\" from typing import List from typing import Tuple from typing import TypeVar from spock.utils import _def_list from spock.utils import _def_tuple class BoolArg ( int ): \"\"\"Spock boolean argument Overloads the bool type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock boolean arg *Args*: x: boolean value *Returns*: boolean variable \"\"\" return super () . __new__ ( cls , bool ( x )) class IntArg ( int ): \"\"\"Spock integer argument Overloads the integer type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock integer arg *Args*: x: integer value *Returns*: integer variable \"\"\" return super () . __new__ ( cls , x ) class IntOptArg ( int ): \"\"\"Spock integer optional argument Overloads the integer type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock optional integer arg *Args*: x: integer value *Returns*: integer variable \"\"\" return super () . __new__ ( cls , x ) class FloatArg ( float ): \"\"\"Spock float argument Overloads the float type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock float arg *Args*: x: float value *Returns*: float variable \"\"\" return super () . __new__ ( cls , x ) class FloatOptArg ( float ): \"\"\"Spock float optional argument Overloads the float type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock float optional arg *Args*: x: float value *Returns*: float variable \"\"\" return super () . __new__ ( cls , x ) class StrArg ( str ): \"\"\"Spock string argument Overloads the string type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock string arg *Args*: x: string value *Returns*: string variable \"\"\" return super () . __new__ ( cls , x ) class StrOptArg ( str ): \"\"\"Spock string optional argument Overloads the string type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock string optional arg *Args*: x: string value *Returns*: string variable \"\"\" return super () . __new__ ( cls , x ) # Make a type var __T = TypeVar ( '__T' ) class ListArg ( List [ __T ]): # pylint: disable=too-few-public-methods \"\"\"Spock list argument Overloads the list type for Spock \"\"\" @staticmethod def defaults ( values : List ): \"\"\"Creates a new instance of a Spock list arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values ) class ListOptArg ( List [ __T ]): # pylint: disable=too-few-public-methods \"\"\"Spock list optional argument Overloads the list type and makes the argument optional for Spock \"\"\" @staticmethod def defaults ( values : List ): \"\"\"Creates a new instance of a Spock list optional arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values ) class TupleArg ( Tuple [ __T ]): # pylint: disable=too-few-public-methods \"\"\"Spock tuple argument Overloads the tuple type for Spock \"\"\" @staticmethod def defaults ( values : Tuple ): \"\"\"Creates a new instance of a Spock tuple arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values ) class TupleOptArg ( Tuple [ __T ]): # pylint: disable=too-few-public-methods \"\"\"Spock tuple optional argument Overloads the tuple type and makes the argument optional for Spock \"\"\" @staticmethod def defaults ( values : Tuple ): \"\"\"Creates a new instance of a Spock tuple optional arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values ) class ChoiceArg : # pylint: disable=too-few-public-methods \"\"\"Spock type of a choice set Requires defaults or file values to be from a predefined set \"\"\" def __init__ ( self , choice_set : List , default = None ): self . choice_set = choice_set self . default = default self . set_type = self . _verify () def _verify ( self ): \"\"\"Validates the types within a set *Returns*: str name of type \"\"\" type_set = { type ( val ) for val in self . choice_set } if len ( type_set ) > 1 : raise TypeError ( f 'ChoiceArg must all be of the same type: {type_set}' ) return list ( type_set )[ 0 ] class SavePathOptArg ( str ): \"\"\"Spock special key for saving the Spock config to file Defines a special key use to save the current Spock config to file \"\"\" def __new__ ( cls , x ): return super () . __new__ ( cls , x ) def boolean_string ( bool_string ): \"\"\"Map boolean string to boolean type *Args*: s: boolean string *Returns*: string True/False to actual bool type \"\"\" if bool_string not in { 'False' , 'True' }: raise ValueError ( 'Not a valid boolean string' ) return bool_string == 'True' Functions boolean_string def boolean_string ( bool_string ) Map boolean string to boolean type Args : s : boolean string Returns : string True/False to actual bool type View Source def boolean_string ( bool_string ): \"\"\"Map boolean string to boolean type *Args*: s: boolean string *Returns*: string True/False to actual bool type \"\"\" if bool_string not in { 'False' , 'True' } : raise ValueError ( 'Not a valid boolean string' ) return bool_string == 'True' Classes BoolArg class BoolArg ( / , * args , ** kwargs ) Spock boolean argument Overloads the bool type for Spock View Source class BoolArg ( int ): \"\"\"Spock boolean argument Overloads the bool type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock boolean arg *Args*: x: boolean value *Returns*: boolean variable \"\"\" return super (). __new__ ( cls , bool ( x )) Ancestors (in MRO) builtins.int Class variables denominator imag numerator real Methods bit_length def bit_length ( self , / ) Number of bits necessary to represent self in binary. bin(37) '0b100101' (37).bit_length() 6 conjugate def conjugate ( ... ) Returns self, the complex conjugate of any int. from_bytes def from_bytes ( bytes , byteorder , * , signed = False ) Return the integer represented by the given array of bytes. bytes Holds the array of bytes to convert. The argument must either support the buffer protocol or be an iterable object producing bytes. Bytes and bytearray are examples of built-in objects that support the buffer protocol. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Indicates whether two's complement is used to represent the integer. to_bytes def to_bytes ( self , / , length , byteorder , * , signed = False ) Return an array of bytes representing an integer. length Length of bytes object to use. An OverflowError is raised if the integer is not representable with the given number of bytes. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Determines whether two's complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. ChoiceArg class ChoiceArg ( choice_set : List , default = None ) Spock type of a choice set Requires defaults or file values to be from a predefined set View Source class ChoiceArg: # pylint: disable=too-few-public-methods \"\"\"Spock type of a choice set Requires defaults or file values to be from a predefined set \"\"\" def __init__ ( self , choice_set: List , default = None ): self . choice_set = choice_set self . default = default self . set_type = self . _verify () def _verify ( self ): \"\"\"Validates the types within a set *Returns*: str name of type \"\"\" type_set = { type ( val ) for val in self . choice_set } if len ( type_set ) > 1 : raise TypeError ( f'ChoiceArg must all be of the same type: { type_set }') return list ( type_set )[ 0 ] FloatArg class FloatArg ( / , * args , ** kwargs ) Spock float argument Overloads the float type for Spock View Source class FloatArg ( float ): \"\"\"Spock float argument Overloads the float type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock float arg *Args*: x: float value *Returns*: float variable \"\"\" return super (). __new__ ( cls , x ) Ancestors (in MRO) builtins.float Class variables imag real Methods as_integer_ratio def as_integer_ratio ( self , / ) Return integer ratio. Return a pair of integers, whose ratio is exactly equal to the original float and with a positive denominator. Raise OverflowError on infinities and a ValueError on NaNs. (10.0).as_integer_ratio() (10, 1) (0.0).as_integer_ratio() (0, 1) (-.25).as_integer_ratio() (-1, 4) conjugate def conjugate ( self , / ) Return self, the complex conjugate of any float. fromhex def fromhex ( string , / ) Create a floating-point number from a hexadecimal string. float.fromhex('0x1.ffffp10') 2047.984375 float.fromhex('-0x1p-1074') -5e-324 hex def hex ( self , / ) Return a hexadecimal representation of a floating-point number. (-0.1).hex() '-0x1.999999999999ap-4' 3.14159.hex() '0x1.921f9f01b866ep+1' is_integer def is_integer ( self , / ) Return True if the float is an integer. FloatOptArg class FloatOptArg ( / , * args , ** kwargs ) Spock float optional argument Overloads the float type and makes the argument optional for Spock View Source class FloatOptArg ( float ): \"\"\"Spock float optional argument Overloads the float type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock float optional arg *Args*: x: float value *Returns*: float variable \"\"\" return super (). __new__ ( cls , x ) Ancestors (in MRO) builtins.float Class variables imag real Methods as_integer_ratio def as_integer_ratio ( self , / ) Return integer ratio. Return a pair of integers, whose ratio is exactly equal to the original float and with a positive denominator. Raise OverflowError on infinities and a ValueError on NaNs. (10.0).as_integer_ratio() (10, 1) (0.0).as_integer_ratio() (0, 1) (-.25).as_integer_ratio() (-1, 4) conjugate def conjugate ( self , / ) Return self, the complex conjugate of any float. fromhex def fromhex ( string , / ) Create a floating-point number from a hexadecimal string. float.fromhex('0x1.ffffp10') 2047.984375 float.fromhex('-0x1p-1074') -5e-324 hex def hex ( self , / ) Return a hexadecimal representation of a floating-point number. (-0.1).hex() '-0x1.999999999999ap-4' 3.14159.hex() '0x1.921f9f01b866ep+1' is_integer def is_integer ( self , / ) Return True if the float is an integer. IntArg class IntArg ( / , * args , ** kwargs ) Spock integer argument Overloads the integer type for Spock View Source class IntArg ( int ): \"\"\"Spock integer argument Overloads the integer type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock integer arg *Args*: x: integer value *Returns*: integer variable \"\"\" return super (). __new__ ( cls , x ) Ancestors (in MRO) builtins.int Class variables denominator imag numerator real Methods bit_length def bit_length ( self , / ) Number of bits necessary to represent self in binary. bin(37) '0b100101' (37).bit_length() 6 conjugate def conjugate ( ... ) Returns self, the complex conjugate of any int. from_bytes def from_bytes ( bytes , byteorder , * , signed = False ) Return the integer represented by the given array of bytes. bytes Holds the array of bytes to convert. The argument must either support the buffer protocol or be an iterable object producing bytes. Bytes and bytearray are examples of built-in objects that support the buffer protocol. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Indicates whether two's complement is used to represent the integer. to_bytes def to_bytes ( self , / , length , byteorder , * , signed = False ) Return an array of bytes representing an integer. length Length of bytes object to use. An OverflowError is raised if the integer is not representable with the given number of bytes. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Determines whether two's complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. IntOptArg class IntOptArg ( / , * args , ** kwargs ) Spock integer optional argument Overloads the integer type and makes the argument optional for Spock View Source class IntOptArg ( int ): \"\"\"Spock integer optional argument Overloads the integer type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock optional integer arg *Args*: x: integer value *Returns*: integer variable \"\"\" return super (). __new__ ( cls , x ) Ancestors (in MRO) builtins.int Class variables denominator imag numerator real Methods bit_length def bit_length ( self , / ) Number of bits necessary to represent self in binary. bin(37) '0b100101' (37).bit_length() 6 conjugate def conjugate ( ... ) Returns self, the complex conjugate of any int. from_bytes def from_bytes ( bytes , byteorder , * , signed = False ) Return the integer represented by the given array of bytes. bytes Holds the array of bytes to convert. The argument must either support the buffer protocol or be an iterable object producing bytes. Bytes and bytearray are examples of built-in objects that support the buffer protocol. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Indicates whether two's complement is used to represent the integer. to_bytes def to_bytes ( self , / , length , byteorder , * , signed = False ) Return an array of bytes representing an integer. length Length of bytes object to use. An OverflowError is raised if the integer is not representable with the given number of bytes. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Determines whether two's complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. ListArg class ListArg ( / , * args , ** kwargs ) Spock list argument Overloads the list type for Spock View Source class ListArg ( List [ __T ] ) : # pylint : disable = too - few - public - methods \"\"\"Spock list argument Overloads the list type for Spock \"\"\" @staticmethod def defaults ( values : List ) : \"\"\"Creates a new instance of a Spock list arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values ) Ancestors (in MRO) builtins.list typing.Generic Static methods defaults def defaults ( values : List ) Creates a new instance of a Spock list arg Args : values : list values Returns : list variable View Source @staticmethod def defaults ( values : List ) : \"\"\"Creates a new instance of a Spock list arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values ) Methods append def append ( self , object , / ) Append object to the end of the list. clear def clear ( self , / ) Remove all items from list. copy def copy ( self , / ) Return a shallow copy of the list. count def count ( self , value , / ) Return number of occurrences of value. extend def extend ( self , iterable , / ) Extend list by appending elements from the iterable. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. insert def insert ( self , index , object , / ) Insert object before index. pop def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. remove def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present. reverse def reverse ( self , / ) Reverse IN PLACE . sort def sort ( self , / , * , key = None , reverse = False ) Stable sort IN PLACE . ListOptArg class ListOptArg ( / , * args , ** kwargs ) Spock list optional argument Overloads the list type and makes the argument optional for Spock View Source class ListOptArg ( List [ __T ] ) : # pylint : disable = too - few - public - methods \"\"\"Spock list optional argument Overloads the list type and makes the argument optional for Spock \"\"\" @staticmethod def defaults ( values : List ) : \"\"\"Creates a new instance of a Spock list optional arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values ) Ancestors (in MRO) builtins.list typing.Generic Static methods defaults def defaults ( values : List ) Creates a new instance of a Spock list optional arg Args : values : list values Returns : list variable View Source @staticmethod def defaults ( values : List ) : \"\"\"Creates a new instance of a Spock list optional arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values ) Methods append def append ( self , object , / ) Append object to the end of the list. clear def clear ( self , / ) Remove all items from list. copy def copy ( self , / ) Return a shallow copy of the list. count def count ( self , value , / ) Return number of occurrences of value. extend def extend ( self , iterable , / ) Extend list by appending elements from the iterable. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. insert def insert ( self , index , object , / ) Insert object before index. pop def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. remove def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present. reverse def reverse ( self , / ) Reverse IN PLACE . sort def sort ( self , / , * , key = None , reverse = False ) Stable sort IN PLACE . SavePathOptArg class SavePathOptArg ( / , * args , ** kwargs ) Spock special key for saving the Spock config to file Defines a special key use to save the current Spock config to file View Source class SavePathOptArg ( str ): \"\"\"Spock special key for saving the Spock config to file Defines a special key use to save the current Spock config to file \"\"\" def __new__ ( cls , x ): return super (). __new__ ( cls , x ) Ancestors (in MRO) builtins.str Static methods maketrans def maketrans ( x , y = None , z = None , / ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. Methods capitalize def capitalize ( self , / ) Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case. casefold def casefold ( self , / ) Return a version of the string suitable for caseless comparisons. center def center ( self , width , fillchar = ' ' , / ) Return a centered string of length width. Padding is done using the specified fill character (default is a space). count def count ( ... ) S.count(sub[, start[, end]]) -> int Return the number of non-overlapping occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation. encode def encode ( self , / , encoding = 'utf-8' , errors = 'strict' ) Encode the string using the codec registered for encoding. encoding The encoding in which to encode the string. errors The error handling scheme to use for encoding errors. The default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors. endswith def endswith ( ... ) S.endswith(suffix[, start[, end]]) -> bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try. expandtabs def expandtabs ( self , / , tabsize = 8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. find def find ( ... ) S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. format def format ( ... ) S.format( args, *kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}'). format_map def format_map ( ... ) S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}'). index def index ( ... ) S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. isalnum def isalnum ( self , / ) Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string. isalpha def isalpha ( self , / ) Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string. isascii def isascii ( self , / ) Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too. isdecimal def isdecimal ( self , / ) Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string. isdigit def isdigit ( self , / ) Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string. isidentifier def isidentifier ( self , / ) Return True if the string is a valid Python identifier, False otherwise. Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\". islower def islower ( self , / ) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string. isnumeric def isnumeric ( self , / ) Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string. isprintable def isprintable ( self , / ) Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty. isspace def isspace ( self , / ) Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string. istitle def istitle ( self , / ) Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. isupper def isupper ( self , / ) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string. join def join ( self , iterable , / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs' ljust def ljust ( self , width , fillchar = ' ' , / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space). lower def lower ( self , / ) Return a copy of the string converted to lowercase. lstrip def lstrip ( self , chars = None , / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead. partition def partition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings. replace def replace ( self , old , new , count =- 1 , / ) Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced. rfind def rfind ( ... ) S.rfind(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. rindex def rindex ( ... ) S.rindex(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. rjust def rjust ( self , width , fillchar = ' ' , / ) Return a right-justified string of length width. Padding is done using the specified fill character (default is a space). rpartition def rpartition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string. rsplit def rsplit ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front. rstrip def rstrip ( self , chars = None , / ) Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead. split def split ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. splitlines def splitlines ( self , / , keepends = False ) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. startswith def startswith ( ... ) S.startswith(prefix[, start[, end]]) -> bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try. strip def strip ( self , chars = None , / ) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead. swapcase def swapcase ( self , / ) Convert uppercase characters to lowercase and lowercase characters to uppercase. title def title ( self , / ) Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case. translate def translate ( self , table , / ) Replace each character in the string using the given translation table. table Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via getitem , for instance a dictionary or list. If this operation raises LookupError, the character is left untouched. Characters mapped to None are deleted. upper def upper ( self , / ) Return a copy of the string converted to uppercase. zfill def zfill ( self , width , / ) Pad a numeric string with zeros on the left, to fill a field of the given width. The string is never truncated. StrArg class StrArg ( / , * args , ** kwargs ) Spock string argument Overloads the string type for Spock View Source class StrArg ( str ): \"\"\"Spock string argument Overloads the string type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock string arg *Args*: x: string value *Returns*: string variable \"\"\" return super (). __new__ ( cls , x ) Ancestors (in MRO) builtins.str Static methods maketrans def maketrans ( x , y = None , z = None , / ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. Methods capitalize def capitalize ( self , / ) Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case. casefold def casefold ( self , / ) Return a version of the string suitable for caseless comparisons. center def center ( self , width , fillchar = ' ' , / ) Return a centered string of length width. Padding is done using the specified fill character (default is a space). count def count ( ... ) S.count(sub[, start[, end]]) -> int Return the number of non-overlapping occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation. encode def encode ( self , / , encoding = 'utf-8' , errors = 'strict' ) Encode the string using the codec registered for encoding. encoding The encoding in which to encode the string. errors The error handling scheme to use for encoding errors. The default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors. endswith def endswith ( ... ) S.endswith(suffix[, start[, end]]) -> bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try. expandtabs def expandtabs ( self , / , tabsize = 8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. find def find ( ... ) S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. format def format ( ... ) S.format( args, *kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}'). format_map def format_map ( ... ) S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}'). index def index ( ... ) S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. isalnum def isalnum ( self , / ) Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string. isalpha def isalpha ( self , / ) Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string. isascii def isascii ( self , / ) Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too. isdecimal def isdecimal ( self , / ) Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string. isdigit def isdigit ( self , / ) Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string. isidentifier def isidentifier ( self , / ) Return True if the string is a valid Python identifier, False otherwise. Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\". islower def islower ( self , / ) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string. isnumeric def isnumeric ( self , / ) Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string. isprintable def isprintable ( self , / ) Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty. isspace def isspace ( self , / ) Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string. istitle def istitle ( self , / ) Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. isupper def isupper ( self , / ) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string. join def join ( self , iterable , / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs' ljust def ljust ( self , width , fillchar = ' ' , / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space). lower def lower ( self , / ) Return a copy of the string converted to lowercase. lstrip def lstrip ( self , chars = None , / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead. partition def partition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings. replace def replace ( self , old , new , count =- 1 , / ) Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced. rfind def rfind ( ... ) S.rfind(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. rindex def rindex ( ... ) S.rindex(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. rjust def rjust ( self , width , fillchar = ' ' , / ) Return a right-justified string of length width. Padding is done using the specified fill character (default is a space). rpartition def rpartition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string. rsplit def rsplit ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front. rstrip def rstrip ( self , chars = None , / ) Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead. split def split ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. splitlines def splitlines ( self , / , keepends = False ) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. startswith def startswith ( ... ) S.startswith(prefix[, start[, end]]) -> bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try. strip def strip ( self , chars = None , / ) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead. swapcase def swapcase ( self , / ) Convert uppercase characters to lowercase and lowercase characters to uppercase. title def title ( self , / ) Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case. translate def translate ( self , table , / ) Replace each character in the string using the given translation table. table Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via getitem , for instance a dictionary or list. If this operation raises LookupError, the character is left untouched. Characters mapped to None are deleted. upper def upper ( self , / ) Return a copy of the string converted to uppercase. zfill def zfill ( self , width , / ) Pad a numeric string with zeros on the left, to fill a field of the given width. The string is never truncated. StrOptArg class StrOptArg ( / , * args , ** kwargs ) Spock string optional argument Overloads the string type and makes the argument optional for Spock View Source class StrOptArg ( str ): \"\"\"Spock string optional argument Overloads the string type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock string optional arg *Args*: x: string value *Returns*: string variable \"\"\" return super (). __new__ ( cls , x ) Ancestors (in MRO) builtins.str Static methods maketrans def maketrans ( x , y = None , z = None , / ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. Methods capitalize def capitalize ( self , / ) Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case. casefold def casefold ( self , / ) Return a version of the string suitable for caseless comparisons. center def center ( self , width , fillchar = ' ' , / ) Return a centered string of length width. Padding is done using the specified fill character (default is a space). count def count ( ... ) S.count(sub[, start[, end]]) -> int Return the number of non-overlapping occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation. encode def encode ( self , / , encoding = 'utf-8' , errors = 'strict' ) Encode the string using the codec registered for encoding. encoding The encoding in which to encode the string. errors The error handling scheme to use for encoding errors. The default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors. endswith def endswith ( ... ) S.endswith(suffix[, start[, end]]) -> bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try. expandtabs def expandtabs ( self , / , tabsize = 8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. find def find ( ... ) S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. format def format ( ... ) S.format( args, *kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}'). format_map def format_map ( ... ) S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}'). index def index ( ... ) S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. isalnum def isalnum ( self , / ) Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string. isalpha def isalpha ( self , / ) Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string. isascii def isascii ( self , / ) Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too. isdecimal def isdecimal ( self , / ) Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string. isdigit def isdigit ( self , / ) Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string. isidentifier def isidentifier ( self , / ) Return True if the string is a valid Python identifier, False otherwise. Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\". islower def islower ( self , / ) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string. isnumeric def isnumeric ( self , / ) Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string. isprintable def isprintable ( self , / ) Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty. isspace def isspace ( self , / ) Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string. istitle def istitle ( self , / ) Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones. isupper def isupper ( self , / ) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string. join def join ( self , iterable , / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs' ljust def ljust ( self , width , fillchar = ' ' , / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space). lower def lower ( self , / ) Return a copy of the string converted to lowercase. lstrip def lstrip ( self , chars = None , / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead. partition def partition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings. replace def replace ( self , old , new , count =- 1 , / ) Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced. rfind def rfind ( ... ) S.rfind(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. rindex def rindex ( ... ) S.rindex(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found. rjust def rjust ( self , width , fillchar = ' ' , / ) Return a right-justified string of length width. Padding is done using the specified fill character (default is a space). rpartition def rpartition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string. rsplit def rsplit ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front. rstrip def rstrip ( self , chars = None , / ) Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead. split def split ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. splitlines def splitlines ( self , / , keepends = False ) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. startswith def startswith ( ... ) S.startswith(prefix[, start[, end]]) -> bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try. strip def strip ( self , chars = None , / ) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead. swapcase def swapcase ( self , / ) Convert uppercase characters to lowercase and lowercase characters to uppercase. title def title ( self , / ) Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case. translate def translate ( self , table , / ) Replace each character in the string using the given translation table. table Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via getitem , for instance a dictionary or list. If this operation raises LookupError, the character is left untouched. Characters mapped to None are deleted. upper def upper ( self , / ) Return a copy of the string converted to uppercase. zfill def zfill ( self , width , / ) Pad a numeric string with zeros on the left, to fill a field of the given width. The string is never truncated. TupleArg class TupleArg ( / , * args , ** kwargs ) Spock tuple argument Overloads the tuple type for Spock View Source class TupleArg ( Tuple [ __T ] ) : # pylint : disable = too - few - public - methods \"\"\"Spock tuple argument Overloads the tuple type for Spock \"\"\" @staticmethod def defaults ( values : Tuple ) : \"\"\"Creates a new instance of a Spock tuple arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values ) Ancestors (in MRO) builtins.tuple typing.Generic Static methods defaults def defaults ( values : Tuple ) Creates a new instance of a Spock tuple arg Args : values : tuple values Returns : tuple variable View Source @staticmethod def defaults ( values : Tuple ) : \"\"\"Creates a new instance of a Spock tuple arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values ) Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. TupleOptArg class TupleOptArg ( / , * args , ** kwargs ) Spock tuple optional argument Overloads the tuple type and makes the argument optional for Spock View Source class TupleOptArg ( Tuple [ __T ] ) : # pylint : disable = too - few - public - methods \"\"\"Spock tuple optional argument Overloads the tuple type and makes the argument optional for Spock \"\"\" @staticmethod def defaults ( values : Tuple ) : \"\"\"Creates a new instance of a Spock tuple optional arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values ) Ancestors (in MRO) builtins.tuple typing.Generic Static methods defaults def defaults ( values : Tuple ) Creates a new instance of a Spock tuple optional arg Args : values : tuple values Returns : tuple variable View Source @staticmethod def defaults ( values : Tuple ) : \"\"\"Creates a new instance of a Spock tuple optional arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values ) Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"Args"},{"location":"reference/spock/args/#module-spockargs","text":"Handles the definitions of arguments types for Spock View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Handles the definitions of arguments types for Spock\"\"\" from typing import List from typing import Tuple from typing import TypeVar from spock.utils import _def_list from spock.utils import _def_tuple class BoolArg ( int ): \"\"\"Spock boolean argument Overloads the bool type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock boolean arg *Args*: x: boolean value *Returns*: boolean variable \"\"\" return super () . __new__ ( cls , bool ( x )) class IntArg ( int ): \"\"\"Spock integer argument Overloads the integer type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock integer arg *Args*: x: integer value *Returns*: integer variable \"\"\" return super () . __new__ ( cls , x ) class IntOptArg ( int ): \"\"\"Spock integer optional argument Overloads the integer type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock optional integer arg *Args*: x: integer value *Returns*: integer variable \"\"\" return super () . __new__ ( cls , x ) class FloatArg ( float ): \"\"\"Spock float argument Overloads the float type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock float arg *Args*: x: float value *Returns*: float variable \"\"\" return super () . __new__ ( cls , x ) class FloatOptArg ( float ): \"\"\"Spock float optional argument Overloads the float type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock float optional arg *Args*: x: float value *Returns*: float variable \"\"\" return super () . __new__ ( cls , x ) class StrArg ( str ): \"\"\"Spock string argument Overloads the string type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock string arg *Args*: x: string value *Returns*: string variable \"\"\" return super () . __new__ ( cls , x ) class StrOptArg ( str ): \"\"\"Spock string optional argument Overloads the string type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock string optional arg *Args*: x: string value *Returns*: string variable \"\"\" return super () . __new__ ( cls , x ) # Make a type var __T = TypeVar ( '__T' ) class ListArg ( List [ __T ]): # pylint: disable=too-few-public-methods \"\"\"Spock list argument Overloads the list type for Spock \"\"\" @staticmethod def defaults ( values : List ): \"\"\"Creates a new instance of a Spock list arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values ) class ListOptArg ( List [ __T ]): # pylint: disable=too-few-public-methods \"\"\"Spock list optional argument Overloads the list type and makes the argument optional for Spock \"\"\" @staticmethod def defaults ( values : List ): \"\"\"Creates a new instance of a Spock list optional arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values ) class TupleArg ( Tuple [ __T ]): # pylint: disable=too-few-public-methods \"\"\"Spock tuple argument Overloads the tuple type for Spock \"\"\" @staticmethod def defaults ( values : Tuple ): \"\"\"Creates a new instance of a Spock tuple arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values ) class TupleOptArg ( Tuple [ __T ]): # pylint: disable=too-few-public-methods \"\"\"Spock tuple optional argument Overloads the tuple type and makes the argument optional for Spock \"\"\" @staticmethod def defaults ( values : Tuple ): \"\"\"Creates a new instance of a Spock tuple optional arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values ) class ChoiceArg : # pylint: disable=too-few-public-methods \"\"\"Spock type of a choice set Requires defaults or file values to be from a predefined set \"\"\" def __init__ ( self , choice_set : List , default = None ): self . choice_set = choice_set self . default = default self . set_type = self . _verify () def _verify ( self ): \"\"\"Validates the types within a set *Returns*: str name of type \"\"\" type_set = { type ( val ) for val in self . choice_set } if len ( type_set ) > 1 : raise TypeError ( f 'ChoiceArg must all be of the same type: {type_set}' ) return list ( type_set )[ 0 ] class SavePathOptArg ( str ): \"\"\"Spock special key for saving the Spock config to file Defines a special key use to save the current Spock config to file \"\"\" def __new__ ( cls , x ): return super () . __new__ ( cls , x ) def boolean_string ( bool_string ): \"\"\"Map boolean string to boolean type *Args*: s: boolean string *Returns*: string True/False to actual bool type \"\"\" if bool_string not in { 'False' , 'True' }: raise ValueError ( 'Not a valid boolean string' ) return bool_string == 'True'","title":"Module spock.args"},{"location":"reference/spock/args/#functions","text":"","title":"Functions"},{"location":"reference/spock/args/#boolean_string","text":"def boolean_string ( bool_string ) Map boolean string to boolean type Args : s : boolean string Returns : string True/False to actual bool type View Source def boolean_string ( bool_string ): \"\"\"Map boolean string to boolean type *Args*: s: boolean string *Returns*: string True/False to actual bool type \"\"\" if bool_string not in { 'False' , 'True' } : raise ValueError ( 'Not a valid boolean string' ) return bool_string == 'True'","title":"boolean_string"},{"location":"reference/spock/args/#classes","text":"","title":"Classes"},{"location":"reference/spock/args/#boolarg","text":"class BoolArg ( / , * args , ** kwargs ) Spock boolean argument Overloads the bool type for Spock View Source class BoolArg ( int ): \"\"\"Spock boolean argument Overloads the bool type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock boolean arg *Args*: x: boolean value *Returns*: boolean variable \"\"\" return super (). __new__ ( cls , bool ( x ))","title":"BoolArg"},{"location":"reference/spock/args/#ancestors-in-mro","text":"builtins.int","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#class-variables","text":"denominator imag numerator real","title":"Class variables"},{"location":"reference/spock/args/#methods","text":"","title":"Methods"},{"location":"reference/spock/args/#bit_length","text":"def bit_length ( self , / ) Number of bits necessary to represent self in binary. bin(37) '0b100101' (37).bit_length() 6","title":"bit_length"},{"location":"reference/spock/args/#conjugate","text":"def conjugate ( ... ) Returns self, the complex conjugate of any int.","title":"conjugate"},{"location":"reference/spock/args/#from_bytes","text":"def from_bytes ( bytes , byteorder , * , signed = False ) Return the integer represented by the given array of bytes. bytes Holds the array of bytes to convert. The argument must either support the buffer protocol or be an iterable object producing bytes. Bytes and bytearray are examples of built-in objects that support the buffer protocol. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Indicates whether two's complement is used to represent the integer.","title":"from_bytes"},{"location":"reference/spock/args/#to_bytes","text":"def to_bytes ( self , / , length , byteorder , * , signed = False ) Return an array of bytes representing an integer. length Length of bytes object to use. An OverflowError is raised if the integer is not representable with the given number of bytes. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Determines whether two's complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised.","title":"to_bytes"},{"location":"reference/spock/args/#choicearg","text":"class ChoiceArg ( choice_set : List , default = None ) Spock type of a choice set Requires defaults or file values to be from a predefined set View Source class ChoiceArg: # pylint: disable=too-few-public-methods \"\"\"Spock type of a choice set Requires defaults or file values to be from a predefined set \"\"\" def __init__ ( self , choice_set: List , default = None ): self . choice_set = choice_set self . default = default self . set_type = self . _verify () def _verify ( self ): \"\"\"Validates the types within a set *Returns*: str name of type \"\"\" type_set = { type ( val ) for val in self . choice_set } if len ( type_set ) > 1 : raise TypeError ( f'ChoiceArg must all be of the same type: { type_set }') return list ( type_set )[ 0 ]","title":"ChoiceArg"},{"location":"reference/spock/args/#floatarg","text":"class FloatArg ( / , * args , ** kwargs ) Spock float argument Overloads the float type for Spock View Source class FloatArg ( float ): \"\"\"Spock float argument Overloads the float type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock float arg *Args*: x: float value *Returns*: float variable \"\"\" return super (). __new__ ( cls , x )","title":"FloatArg"},{"location":"reference/spock/args/#ancestors-in-mro_1","text":"builtins.float","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#class-variables_1","text":"imag real","title":"Class variables"},{"location":"reference/spock/args/#methods_1","text":"","title":"Methods"},{"location":"reference/spock/args/#as_integer_ratio","text":"def as_integer_ratio ( self , / ) Return integer ratio. Return a pair of integers, whose ratio is exactly equal to the original float and with a positive denominator. Raise OverflowError on infinities and a ValueError on NaNs. (10.0).as_integer_ratio() (10, 1) (0.0).as_integer_ratio() (0, 1) (-.25).as_integer_ratio() (-1, 4)","title":"as_integer_ratio"},{"location":"reference/spock/args/#conjugate_1","text":"def conjugate ( self , / ) Return self, the complex conjugate of any float.","title":"conjugate"},{"location":"reference/spock/args/#fromhex","text":"def fromhex ( string , / ) Create a floating-point number from a hexadecimal string. float.fromhex('0x1.ffffp10') 2047.984375 float.fromhex('-0x1p-1074') -5e-324","title":"fromhex"},{"location":"reference/spock/args/#hex","text":"def hex ( self , / ) Return a hexadecimal representation of a floating-point number. (-0.1).hex() '-0x1.999999999999ap-4' 3.14159.hex() '0x1.921f9f01b866ep+1'","title":"hex"},{"location":"reference/spock/args/#is_integer","text":"def is_integer ( self , / ) Return True if the float is an integer.","title":"is_integer"},{"location":"reference/spock/args/#floatoptarg","text":"class FloatOptArg ( / , * args , ** kwargs ) Spock float optional argument Overloads the float type and makes the argument optional for Spock View Source class FloatOptArg ( float ): \"\"\"Spock float optional argument Overloads the float type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock float optional arg *Args*: x: float value *Returns*: float variable \"\"\" return super (). __new__ ( cls , x )","title":"FloatOptArg"},{"location":"reference/spock/args/#ancestors-in-mro_2","text":"builtins.float","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#class-variables_2","text":"imag real","title":"Class variables"},{"location":"reference/spock/args/#methods_2","text":"","title":"Methods"},{"location":"reference/spock/args/#as_integer_ratio_1","text":"def as_integer_ratio ( self , / ) Return integer ratio. Return a pair of integers, whose ratio is exactly equal to the original float and with a positive denominator. Raise OverflowError on infinities and a ValueError on NaNs. (10.0).as_integer_ratio() (10, 1) (0.0).as_integer_ratio() (0, 1) (-.25).as_integer_ratio() (-1, 4)","title":"as_integer_ratio"},{"location":"reference/spock/args/#conjugate_2","text":"def conjugate ( self , / ) Return self, the complex conjugate of any float.","title":"conjugate"},{"location":"reference/spock/args/#fromhex_1","text":"def fromhex ( string , / ) Create a floating-point number from a hexadecimal string. float.fromhex('0x1.ffffp10') 2047.984375 float.fromhex('-0x1p-1074') -5e-324","title":"fromhex"},{"location":"reference/spock/args/#hex_1","text":"def hex ( self , / ) Return a hexadecimal representation of a floating-point number. (-0.1).hex() '-0x1.999999999999ap-4' 3.14159.hex() '0x1.921f9f01b866ep+1'","title":"hex"},{"location":"reference/spock/args/#is_integer_1","text":"def is_integer ( self , / ) Return True if the float is an integer.","title":"is_integer"},{"location":"reference/spock/args/#intarg","text":"class IntArg ( / , * args , ** kwargs ) Spock integer argument Overloads the integer type for Spock View Source class IntArg ( int ): \"\"\"Spock integer argument Overloads the integer type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock integer arg *Args*: x: integer value *Returns*: integer variable \"\"\" return super (). __new__ ( cls , x )","title":"IntArg"},{"location":"reference/spock/args/#ancestors-in-mro_3","text":"builtins.int","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#class-variables_3","text":"denominator imag numerator real","title":"Class variables"},{"location":"reference/spock/args/#methods_3","text":"","title":"Methods"},{"location":"reference/spock/args/#bit_length_1","text":"def bit_length ( self , / ) Number of bits necessary to represent self in binary. bin(37) '0b100101' (37).bit_length() 6","title":"bit_length"},{"location":"reference/spock/args/#conjugate_3","text":"def conjugate ( ... ) Returns self, the complex conjugate of any int.","title":"conjugate"},{"location":"reference/spock/args/#from_bytes_1","text":"def from_bytes ( bytes , byteorder , * , signed = False ) Return the integer represented by the given array of bytes. bytes Holds the array of bytes to convert. The argument must either support the buffer protocol or be an iterable object producing bytes. Bytes and bytearray are examples of built-in objects that support the buffer protocol. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Indicates whether two's complement is used to represent the integer.","title":"from_bytes"},{"location":"reference/spock/args/#to_bytes_1","text":"def to_bytes ( self , / , length , byteorder , * , signed = False ) Return an array of bytes representing an integer. length Length of bytes object to use. An OverflowError is raised if the integer is not representable with the given number of bytes. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Determines whether two's complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised.","title":"to_bytes"},{"location":"reference/spock/args/#intoptarg","text":"class IntOptArg ( / , * args , ** kwargs ) Spock integer optional argument Overloads the integer type and makes the argument optional for Spock View Source class IntOptArg ( int ): \"\"\"Spock integer optional argument Overloads the integer type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock optional integer arg *Args*: x: integer value *Returns*: integer variable \"\"\" return super (). __new__ ( cls , x )","title":"IntOptArg"},{"location":"reference/spock/args/#ancestors-in-mro_4","text":"builtins.int","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#class-variables_4","text":"denominator imag numerator real","title":"Class variables"},{"location":"reference/spock/args/#methods_4","text":"","title":"Methods"},{"location":"reference/spock/args/#bit_length_2","text":"def bit_length ( self , / ) Number of bits necessary to represent self in binary. bin(37) '0b100101' (37).bit_length() 6","title":"bit_length"},{"location":"reference/spock/args/#conjugate_4","text":"def conjugate ( ... ) Returns self, the complex conjugate of any int.","title":"conjugate"},{"location":"reference/spock/args/#from_bytes_2","text":"def from_bytes ( bytes , byteorder , * , signed = False ) Return the integer represented by the given array of bytes. bytes Holds the array of bytes to convert. The argument must either support the buffer protocol or be an iterable object producing bytes. Bytes and bytearray are examples of built-in objects that support the buffer protocol. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Indicates whether two's complement is used to represent the integer.","title":"from_bytes"},{"location":"reference/spock/args/#to_bytes_2","text":"def to_bytes ( self , / , length , byteorder , * , signed = False ) Return an array of bytes representing an integer. length Length of bytes object to use. An OverflowError is raised if the integer is not representable with the given number of bytes. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. signed Determines whether two's complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised.","title":"to_bytes"},{"location":"reference/spock/args/#listarg","text":"class ListArg ( / , * args , ** kwargs ) Spock list argument Overloads the list type for Spock View Source class ListArg ( List [ __T ] ) : # pylint : disable = too - few - public - methods \"\"\"Spock list argument Overloads the list type for Spock \"\"\" @staticmethod def defaults ( values : List ) : \"\"\"Creates a new instance of a Spock list arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values )","title":"ListArg"},{"location":"reference/spock/args/#ancestors-in-mro_5","text":"builtins.list typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#static-methods","text":"","title":"Static methods"},{"location":"reference/spock/args/#defaults","text":"def defaults ( values : List ) Creates a new instance of a Spock list arg Args : values : list values Returns : list variable View Source @staticmethod def defaults ( values : List ) : \"\"\"Creates a new instance of a Spock list arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values )","title":"defaults"},{"location":"reference/spock/args/#methods_5","text":"","title":"Methods"},{"location":"reference/spock/args/#append","text":"def append ( self , object , / ) Append object to the end of the list.","title":"append"},{"location":"reference/spock/args/#clear","text":"def clear ( self , / ) Remove all items from list.","title":"clear"},{"location":"reference/spock/args/#copy","text":"def copy ( self , / ) Return a shallow copy of the list.","title":"copy"},{"location":"reference/spock/args/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/spock/args/#extend","text":"def extend ( self , iterable , / ) Extend list by appending elements from the iterable.","title":"extend"},{"location":"reference/spock/args/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/spock/args/#insert","text":"def insert ( self , index , object , / ) Insert object before index.","title":"insert"},{"location":"reference/spock/args/#pop","text":"def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range.","title":"pop"},{"location":"reference/spock/args/#remove","text":"def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present.","title":"remove"},{"location":"reference/spock/args/#reverse","text":"def reverse ( self , / ) Reverse IN PLACE .","title":"reverse"},{"location":"reference/spock/args/#sort","text":"def sort ( self , / , * , key = None , reverse = False ) Stable sort IN PLACE .","title":"sort"},{"location":"reference/spock/args/#listoptarg","text":"class ListOptArg ( / , * args , ** kwargs ) Spock list optional argument Overloads the list type and makes the argument optional for Spock View Source class ListOptArg ( List [ __T ] ) : # pylint : disable = too - few - public - methods \"\"\"Spock list optional argument Overloads the list type and makes the argument optional for Spock \"\"\" @staticmethod def defaults ( values : List ) : \"\"\"Creates a new instance of a Spock list optional arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values )","title":"ListOptArg"},{"location":"reference/spock/args/#ancestors-in-mro_6","text":"builtins.list typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/spock/args/#defaults_1","text":"def defaults ( values : List ) Creates a new instance of a Spock list optional arg Args : values : list values Returns : list variable View Source @staticmethod def defaults ( values : List ) : \"\"\"Creates a new instance of a Spock list optional arg *Args*: values: list values *Returns*: list variable \"\"\" return _def_list ( values )","title":"defaults"},{"location":"reference/spock/args/#methods_6","text":"","title":"Methods"},{"location":"reference/spock/args/#append_1","text":"def append ( self , object , / ) Append object to the end of the list.","title":"append"},{"location":"reference/spock/args/#clear_1","text":"def clear ( self , / ) Remove all items from list.","title":"clear"},{"location":"reference/spock/args/#copy_1","text":"def copy ( self , / ) Return a shallow copy of the list.","title":"copy"},{"location":"reference/spock/args/#count_1","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/spock/args/#extend_1","text":"def extend ( self , iterable , / ) Extend list by appending elements from the iterable.","title":"extend"},{"location":"reference/spock/args/#index_1","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/spock/args/#insert_1","text":"def insert ( self , index , object , / ) Insert object before index.","title":"insert"},{"location":"reference/spock/args/#pop_1","text":"def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range.","title":"pop"},{"location":"reference/spock/args/#remove_1","text":"def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present.","title":"remove"},{"location":"reference/spock/args/#reverse_1","text":"def reverse ( self , / ) Reverse IN PLACE .","title":"reverse"},{"location":"reference/spock/args/#sort_1","text":"def sort ( self , / , * , key = None , reverse = False ) Stable sort IN PLACE .","title":"sort"},{"location":"reference/spock/args/#savepathoptarg","text":"class SavePathOptArg ( / , * args , ** kwargs ) Spock special key for saving the Spock config to file Defines a special key use to save the current Spock config to file View Source class SavePathOptArg ( str ): \"\"\"Spock special key for saving the Spock config to file Defines a special key use to save the current Spock config to file \"\"\" def __new__ ( cls , x ): return super (). __new__ ( cls , x )","title":"SavePathOptArg"},{"location":"reference/spock/args/#ancestors-in-mro_7","text":"builtins.str","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/spock/args/#maketrans","text":"def maketrans ( x , y = None , z = None , / ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result.","title":"maketrans"},{"location":"reference/spock/args/#methods_7","text":"","title":"Methods"},{"location":"reference/spock/args/#capitalize","text":"def capitalize ( self , / ) Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case.","title":"capitalize"},{"location":"reference/spock/args/#casefold","text":"def casefold ( self , / ) Return a version of the string suitable for caseless comparisons.","title":"casefold"},{"location":"reference/spock/args/#center","text":"def center ( self , width , fillchar = ' ' , / ) Return a centered string of length width. Padding is done using the specified fill character (default is a space).","title":"center"},{"location":"reference/spock/args/#count_2","text":"def count ( ... ) S.count(sub[, start[, end]]) -> int Return the number of non-overlapping occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation.","title":"count"},{"location":"reference/spock/args/#encode","text":"def encode ( self , / , encoding = 'utf-8' , errors = 'strict' ) Encode the string using the codec registered for encoding. encoding The encoding in which to encode the string. errors The error handling scheme to use for encoding errors. The default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors.","title":"encode"},{"location":"reference/spock/args/#endswith","text":"def endswith ( ... ) S.endswith(suffix[, start[, end]]) -> bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try.","title":"endswith"},{"location":"reference/spock/args/#expandtabs","text":"def expandtabs ( self , / , tabsize = 8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed.","title":"expandtabs"},{"location":"reference/spock/args/#find","text":"def find ( ... ) S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.","title":"find"},{"location":"reference/spock/args/#format","text":"def format ( ... ) S.format( args, *kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}').","title":"format"},{"location":"reference/spock/args/#format_map","text":"def format_map ( ... ) S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}').","title":"format_map"},{"location":"reference/spock/args/#index_2","text":"def index ( ... ) S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.","title":"index"},{"location":"reference/spock/args/#isalnum","text":"def isalnum ( self , / ) Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string.","title":"isalnum"},{"location":"reference/spock/args/#isalpha","text":"def isalpha ( self , / ) Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string.","title":"isalpha"},{"location":"reference/spock/args/#isascii","text":"def isascii ( self , / ) Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too.","title":"isascii"},{"location":"reference/spock/args/#isdecimal","text":"def isdecimal ( self , / ) Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string.","title":"isdecimal"},{"location":"reference/spock/args/#isdigit","text":"def isdigit ( self , / ) Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string.","title":"isdigit"},{"location":"reference/spock/args/#isidentifier","text":"def isidentifier ( self , / ) Return True if the string is a valid Python identifier, False otherwise. Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\".","title":"isidentifier"},{"location":"reference/spock/args/#islower","text":"def islower ( self , / ) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string.","title":"islower"},{"location":"reference/spock/args/#isnumeric","text":"def isnumeric ( self , / ) Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string.","title":"isnumeric"},{"location":"reference/spock/args/#isprintable","text":"def isprintable ( self , / ) Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty.","title":"isprintable"},{"location":"reference/spock/args/#isspace","text":"def isspace ( self , / ) Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string.","title":"isspace"},{"location":"reference/spock/args/#istitle","text":"def istitle ( self , / ) Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones.","title":"istitle"},{"location":"reference/spock/args/#isupper","text":"def isupper ( self , / ) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string.","title":"isupper"},{"location":"reference/spock/args/#join","text":"def join ( self , iterable , / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'","title":"join"},{"location":"reference/spock/args/#ljust","text":"def ljust ( self , width , fillchar = ' ' , / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space).","title":"ljust"},{"location":"reference/spock/args/#lower","text":"def lower ( self , / ) Return a copy of the string converted to lowercase.","title":"lower"},{"location":"reference/spock/args/#lstrip","text":"def lstrip ( self , chars = None , / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"lstrip"},{"location":"reference/spock/args/#partition","text":"def partition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings.","title":"partition"},{"location":"reference/spock/args/#replace","text":"def replace ( self , old , new , count =- 1 , / ) Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced.","title":"replace"},{"location":"reference/spock/args/#rfind","text":"def rfind ( ... ) S.rfind(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.","title":"rfind"},{"location":"reference/spock/args/#rindex","text":"def rindex ( ... ) S.rindex(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.","title":"rindex"},{"location":"reference/spock/args/#rjust","text":"def rjust ( self , width , fillchar = ' ' , / ) Return a right-justified string of length width. Padding is done using the specified fill character (default is a space).","title":"rjust"},{"location":"reference/spock/args/#rpartition","text":"def rpartition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string.","title":"rpartition"},{"location":"reference/spock/args/#rsplit","text":"def rsplit ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front.","title":"rsplit"},{"location":"reference/spock/args/#rstrip","text":"def rstrip ( self , chars = None , / ) Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"rstrip"},{"location":"reference/spock/args/#split","text":"def split ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit.","title":"split"},{"location":"reference/spock/args/#splitlines","text":"def splitlines ( self , / , keepends = False ) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true.","title":"splitlines"},{"location":"reference/spock/args/#startswith","text":"def startswith ( ... ) S.startswith(prefix[, start[, end]]) -> bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try.","title":"startswith"},{"location":"reference/spock/args/#strip","text":"def strip ( self , chars = None , / ) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"strip"},{"location":"reference/spock/args/#swapcase","text":"def swapcase ( self , / ) Convert uppercase characters to lowercase and lowercase characters to uppercase.","title":"swapcase"},{"location":"reference/spock/args/#title","text":"def title ( self , / ) Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case.","title":"title"},{"location":"reference/spock/args/#translate","text":"def translate ( self , table , / ) Replace each character in the string using the given translation table. table Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via getitem , for instance a dictionary or list. If this operation raises LookupError, the character is left untouched. Characters mapped to None are deleted.","title":"translate"},{"location":"reference/spock/args/#upper","text":"def upper ( self , / ) Return a copy of the string converted to uppercase.","title":"upper"},{"location":"reference/spock/args/#zfill","text":"def zfill ( self , width , / ) Pad a numeric string with zeros on the left, to fill a field of the given width. The string is never truncated.","title":"zfill"},{"location":"reference/spock/args/#strarg","text":"class StrArg ( / , * args , ** kwargs ) Spock string argument Overloads the string type for Spock View Source class StrArg ( str ): \"\"\"Spock string argument Overloads the string type for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock string arg *Args*: x: string value *Returns*: string variable \"\"\" return super (). __new__ ( cls , x )","title":"StrArg"},{"location":"reference/spock/args/#ancestors-in-mro_8","text":"builtins.str","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/spock/args/#maketrans_1","text":"def maketrans ( x , y = None , z = None , / ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result.","title":"maketrans"},{"location":"reference/spock/args/#methods_8","text":"","title":"Methods"},{"location":"reference/spock/args/#capitalize_1","text":"def capitalize ( self , / ) Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case.","title":"capitalize"},{"location":"reference/spock/args/#casefold_1","text":"def casefold ( self , / ) Return a version of the string suitable for caseless comparisons.","title":"casefold"},{"location":"reference/spock/args/#center_1","text":"def center ( self , width , fillchar = ' ' , / ) Return a centered string of length width. Padding is done using the specified fill character (default is a space).","title":"center"},{"location":"reference/spock/args/#count_3","text":"def count ( ... ) S.count(sub[, start[, end]]) -> int Return the number of non-overlapping occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation.","title":"count"},{"location":"reference/spock/args/#encode_1","text":"def encode ( self , / , encoding = 'utf-8' , errors = 'strict' ) Encode the string using the codec registered for encoding. encoding The encoding in which to encode the string. errors The error handling scheme to use for encoding errors. The default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors.","title":"encode"},{"location":"reference/spock/args/#endswith_1","text":"def endswith ( ... ) S.endswith(suffix[, start[, end]]) -> bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try.","title":"endswith"},{"location":"reference/spock/args/#expandtabs_1","text":"def expandtabs ( self , / , tabsize = 8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed.","title":"expandtabs"},{"location":"reference/spock/args/#find_1","text":"def find ( ... ) S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.","title":"find"},{"location":"reference/spock/args/#format_1","text":"def format ( ... ) S.format( args, *kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}').","title":"format"},{"location":"reference/spock/args/#format_map_1","text":"def format_map ( ... ) S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}').","title":"format_map"},{"location":"reference/spock/args/#index_3","text":"def index ( ... ) S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.","title":"index"},{"location":"reference/spock/args/#isalnum_1","text":"def isalnum ( self , / ) Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string.","title":"isalnum"},{"location":"reference/spock/args/#isalpha_1","text":"def isalpha ( self , / ) Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string.","title":"isalpha"},{"location":"reference/spock/args/#isascii_1","text":"def isascii ( self , / ) Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too.","title":"isascii"},{"location":"reference/spock/args/#isdecimal_1","text":"def isdecimal ( self , / ) Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string.","title":"isdecimal"},{"location":"reference/spock/args/#isdigit_1","text":"def isdigit ( self , / ) Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string.","title":"isdigit"},{"location":"reference/spock/args/#isidentifier_1","text":"def isidentifier ( self , / ) Return True if the string is a valid Python identifier, False otherwise. Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\".","title":"isidentifier"},{"location":"reference/spock/args/#islower_1","text":"def islower ( self , / ) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string.","title":"islower"},{"location":"reference/spock/args/#isnumeric_1","text":"def isnumeric ( self , / ) Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string.","title":"isnumeric"},{"location":"reference/spock/args/#isprintable_1","text":"def isprintable ( self , / ) Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty.","title":"isprintable"},{"location":"reference/spock/args/#isspace_1","text":"def isspace ( self , / ) Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string.","title":"isspace"},{"location":"reference/spock/args/#istitle_1","text":"def istitle ( self , / ) Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones.","title":"istitle"},{"location":"reference/spock/args/#isupper_1","text":"def isupper ( self , / ) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string.","title":"isupper"},{"location":"reference/spock/args/#join_1","text":"def join ( self , iterable , / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'","title":"join"},{"location":"reference/spock/args/#ljust_1","text":"def ljust ( self , width , fillchar = ' ' , / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space).","title":"ljust"},{"location":"reference/spock/args/#lower_1","text":"def lower ( self , / ) Return a copy of the string converted to lowercase.","title":"lower"},{"location":"reference/spock/args/#lstrip_1","text":"def lstrip ( self , chars = None , / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"lstrip"},{"location":"reference/spock/args/#partition_1","text":"def partition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings.","title":"partition"},{"location":"reference/spock/args/#replace_1","text":"def replace ( self , old , new , count =- 1 , / ) Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced.","title":"replace"},{"location":"reference/spock/args/#rfind_1","text":"def rfind ( ... ) S.rfind(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.","title":"rfind"},{"location":"reference/spock/args/#rindex_1","text":"def rindex ( ... ) S.rindex(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.","title":"rindex"},{"location":"reference/spock/args/#rjust_1","text":"def rjust ( self , width , fillchar = ' ' , / ) Return a right-justified string of length width. Padding is done using the specified fill character (default is a space).","title":"rjust"},{"location":"reference/spock/args/#rpartition_1","text":"def rpartition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string.","title":"rpartition"},{"location":"reference/spock/args/#rsplit_1","text":"def rsplit ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front.","title":"rsplit"},{"location":"reference/spock/args/#rstrip_1","text":"def rstrip ( self , chars = None , / ) Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"rstrip"},{"location":"reference/spock/args/#split_1","text":"def split ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit.","title":"split"},{"location":"reference/spock/args/#splitlines_1","text":"def splitlines ( self , / , keepends = False ) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true.","title":"splitlines"},{"location":"reference/spock/args/#startswith_1","text":"def startswith ( ... ) S.startswith(prefix[, start[, end]]) -> bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try.","title":"startswith"},{"location":"reference/spock/args/#strip_1","text":"def strip ( self , chars = None , / ) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"strip"},{"location":"reference/spock/args/#swapcase_1","text":"def swapcase ( self , / ) Convert uppercase characters to lowercase and lowercase characters to uppercase.","title":"swapcase"},{"location":"reference/spock/args/#title_1","text":"def title ( self , / ) Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case.","title":"title"},{"location":"reference/spock/args/#translate_1","text":"def translate ( self , table , / ) Replace each character in the string using the given translation table. table Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via getitem , for instance a dictionary or list. If this operation raises LookupError, the character is left untouched. Characters mapped to None are deleted.","title":"translate"},{"location":"reference/spock/args/#upper_1","text":"def upper ( self , / ) Return a copy of the string converted to uppercase.","title":"upper"},{"location":"reference/spock/args/#zfill_1","text":"def zfill ( self , width , / ) Pad a numeric string with zeros on the left, to fill a field of the given width. The string is never truncated.","title":"zfill"},{"location":"reference/spock/args/#stroptarg","text":"class StrOptArg ( / , * args , ** kwargs ) Spock string optional argument Overloads the string type and makes the argument optional for Spock View Source class StrOptArg ( str ): \"\"\"Spock string optional argument Overloads the string type and makes the argument optional for Spock \"\"\" def __new__ ( cls , x ): \"\"\"Creates a new instance of a Spock string optional arg *Args*: x: string value *Returns*: string variable \"\"\" return super (). __new__ ( cls , x )","title":"StrOptArg"},{"location":"reference/spock/args/#ancestors-in-mro_9","text":"builtins.str","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/spock/args/#maketrans_2","text":"def maketrans ( x , y = None , z = None , / ) Return a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters to Unicode ordinals, strings or None. Character keys will be then converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to None in the result.","title":"maketrans"},{"location":"reference/spock/args/#methods_9","text":"","title":"Methods"},{"location":"reference/spock/args/#capitalize_2","text":"def capitalize ( self , / ) Return a capitalized version of the string. More specifically, make the first character have upper case and the rest lower case.","title":"capitalize"},{"location":"reference/spock/args/#casefold_2","text":"def casefold ( self , / ) Return a version of the string suitable for caseless comparisons.","title":"casefold"},{"location":"reference/spock/args/#center_2","text":"def center ( self , width , fillchar = ' ' , / ) Return a centered string of length width. Padding is done using the specified fill character (default is a space).","title":"center"},{"location":"reference/spock/args/#count_4","text":"def count ( ... ) S.count(sub[, start[, end]]) -> int Return the number of non-overlapping occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation.","title":"count"},{"location":"reference/spock/args/#encode_2","text":"def encode ( self , / , encoding = 'utf-8' , errors = 'strict' ) Encode the string using the codec registered for encoding. encoding The encoding in which to encode the string. errors The error handling scheme to use for encoding errors. The default is 'strict' meaning that encoding errors raise a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and 'xmlcharrefreplace' as well as any other name registered with codecs.register_error that can handle UnicodeEncodeErrors.","title":"encode"},{"location":"reference/spock/args/#endswith_2","text":"def endswith ( ... ) S.endswith(suffix[, start[, end]]) -> bool Return True if S ends with the specified suffix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. suffix can also be a tuple of strings to try.","title":"endswith"},{"location":"reference/spock/args/#expandtabs_2","text":"def expandtabs ( self , / , tabsize = 8 ) Return a copy where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed.","title":"expandtabs"},{"location":"reference/spock/args/#find_2","text":"def find ( ... ) S.find(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.","title":"find"},{"location":"reference/spock/args/#format_2","text":"def format ( ... ) S.format( args, *kwargs) -> str Return a formatted version of S, using substitutions from args and kwargs. The substitutions are identified by braces ('{' and '}').","title":"format"},{"location":"reference/spock/args/#format_map_2","text":"def format_map ( ... ) S.format_map(mapping) -> str Return a formatted version of S, using substitutions from mapping. The substitutions are identified by braces ('{' and '}').","title":"format_map"},{"location":"reference/spock/args/#index_4","text":"def index ( ... ) S.index(sub[, start[, end]]) -> int Return the lowest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.","title":"index"},{"location":"reference/spock/args/#isalnum_2","text":"def isalnum ( self , / ) Return True if the string is an alpha-numeric string, False otherwise. A string is alpha-numeric if all characters in the string are alpha-numeric and there is at least one character in the string.","title":"isalnum"},{"location":"reference/spock/args/#isalpha_2","text":"def isalpha ( self , / ) Return True if the string is an alphabetic string, False otherwise. A string is alphabetic if all characters in the string are alphabetic and there is at least one character in the string.","title":"isalpha"},{"location":"reference/spock/args/#isascii_2","text":"def isascii ( self , / ) Return True if all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too.","title":"isascii"},{"location":"reference/spock/args/#isdecimal_2","text":"def isdecimal ( self , / ) Return True if the string is a decimal string, False otherwise. A string is a decimal string if all characters in the string are decimal and there is at least one character in the string.","title":"isdecimal"},{"location":"reference/spock/args/#isdigit_2","text":"def isdigit ( self , / ) Return True if the string is a digit string, False otherwise. A string is a digit string if all characters in the string are digits and there is at least one character in the string.","title":"isdigit"},{"location":"reference/spock/args/#isidentifier_2","text":"def isidentifier ( self , / ) Return True if the string is a valid Python identifier, False otherwise. Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and \"class\".","title":"isidentifier"},{"location":"reference/spock/args/#islower_2","text":"def islower ( self , / ) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string.","title":"islower"},{"location":"reference/spock/args/#isnumeric_2","text":"def isnumeric ( self , / ) Return True if the string is a numeric string, False otherwise. A string is numeric if all characters in the string are numeric and there is at least one character in the string.","title":"isnumeric"},{"location":"reference/spock/args/#isprintable_2","text":"def isprintable ( self , / ) Return True if the string is printable, False otherwise. A string is printable if all of its characters are considered printable in repr() or if it is empty.","title":"isprintable"},{"location":"reference/spock/args/#isspace_2","text":"def isspace ( self , / ) Return True if the string is a whitespace string, False otherwise. A string is whitespace if all characters in the string are whitespace and there is at least one character in the string.","title":"isspace"},{"location":"reference/spock/args/#istitle_2","text":"def istitle ( self , / ) Return True if the string is a title-cased string, False otherwise. In a title-cased string, upper- and title-case characters may only follow uncased characters and lowercase characters only cased ones.","title":"istitle"},{"location":"reference/spock/args/#isupper_2","text":"def isupper ( self , / ) Return True if the string is an uppercase string, False otherwise. A string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string.","title":"isupper"},{"location":"reference/spock/args/#join_2","text":"def join ( self , iterable , / ) Concatenate any number of strings. The string whose method is called is inserted in between each given string. The result is returned as a new string. Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'","title":"join"},{"location":"reference/spock/args/#ljust_2","text":"def ljust ( self , width , fillchar = ' ' , / ) Return a left-justified string of length width. Padding is done using the specified fill character (default is a space).","title":"ljust"},{"location":"reference/spock/args/#lower_2","text":"def lower ( self , / ) Return a copy of the string converted to lowercase.","title":"lower"},{"location":"reference/spock/args/#lstrip_2","text":"def lstrip ( self , chars = None , / ) Return a copy of the string with leading whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"lstrip"},{"location":"reference/spock/args/#partition_2","text":"def partition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing the original string and two empty strings.","title":"partition"},{"location":"reference/spock/args/#replace_2","text":"def replace ( self , old , new , count =- 1 , / ) Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced.","title":"replace"},{"location":"reference/spock/args/#rfind_2","text":"def rfind ( ... ) S.rfind(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure.","title":"rfind"},{"location":"reference/spock/args/#rindex_2","text":"def rindex ( ... ) S.rindex(sub[, start[, end]]) -> int Return the highest index in S where substring sub is found, such that sub is contained within S[start:end]. Optional arguments start and end are interpreted as in slice notation. Raises ValueError when the substring is not found.","title":"rindex"},{"location":"reference/spock/args/#rjust_2","text":"def rjust ( self , width , fillchar = ' ' , / ) Return a right-justified string of length width. Padding is done using the specified fill character (default is a space).","title":"rjust"},{"location":"reference/spock/args/#rpartition_2","text":"def rpartition ( self , sep , / ) Partition the string into three parts using the given separator. This will search for the separator in the string, starting at the end. If the separator is found, returns a 3-tuple containing the part before the separator, the separator itself, and the part after it. If the separator is not found, returns a 3-tuple containing two empty strings and the original string.","title":"rpartition"},{"location":"reference/spock/args/#rsplit_2","text":"def rsplit ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Splits are done starting at the end of the string and working to the front.","title":"rsplit"},{"location":"reference/spock/args/#rstrip_2","text":"def rstrip ( self , chars = None , / ) Return a copy of the string with trailing whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"rstrip"},{"location":"reference/spock/args/#split_2","text":"def split ( self , / , sep = None , maxsplit =- 1 ) Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit.","title":"split"},{"location":"reference/spock/args/#splitlines_2","text":"def splitlines ( self , / , keepends = False ) Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true.","title":"splitlines"},{"location":"reference/spock/args/#startswith_2","text":"def startswith ( ... ) S.startswith(prefix[, start[, end]]) -> bool Return True if S starts with the specified prefix, False otherwise. With optional start, test S beginning at that position. With optional end, stop comparing S at that position. prefix can also be a tuple of strings to try.","title":"startswith"},{"location":"reference/spock/args/#strip_2","text":"def strip ( self , chars = None , / ) Return a copy of the string with leading and trailing whitespace removed. If chars is given and not None, remove characters in chars instead.","title":"strip"},{"location":"reference/spock/args/#swapcase_2","text":"def swapcase ( self , / ) Convert uppercase characters to lowercase and lowercase characters to uppercase.","title":"swapcase"},{"location":"reference/spock/args/#title_2","text":"def title ( self , / ) Return a version of the string where each word is titlecased. More specifically, words start with uppercased characters and all remaining cased characters have lower case.","title":"title"},{"location":"reference/spock/args/#translate_2","text":"def translate ( self , table , / ) Replace each character in the string using the given translation table. table Translation table, which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. The table must implement lookup/indexing via getitem , for instance a dictionary or list. If this operation raises LookupError, the character is left untouched. Characters mapped to None are deleted.","title":"translate"},{"location":"reference/spock/args/#upper_2","text":"def upper ( self , / ) Return a copy of the string converted to uppercase.","title":"upper"},{"location":"reference/spock/args/#zfill_2","text":"def zfill ( self , width , / ) Pad a numeric string with zeros on the left, to fill a field of the given width. The string is never truncated.","title":"zfill"},{"location":"reference/spock/args/#tuplearg","text":"class TupleArg ( / , * args , ** kwargs ) Spock tuple argument Overloads the tuple type for Spock View Source class TupleArg ( Tuple [ __T ] ) : # pylint : disable = too - few - public - methods \"\"\"Spock tuple argument Overloads the tuple type for Spock \"\"\" @staticmethod def defaults ( values : Tuple ) : \"\"\"Creates a new instance of a Spock tuple arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values )","title":"TupleArg"},{"location":"reference/spock/args/#ancestors-in-mro_10","text":"builtins.tuple typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#static-methods_5","text":"","title":"Static methods"},{"location":"reference/spock/args/#defaults_2","text":"def defaults ( values : Tuple ) Creates a new instance of a Spock tuple arg Args : values : tuple values Returns : tuple variable View Source @staticmethod def defaults ( values : Tuple ) : \"\"\"Creates a new instance of a Spock tuple arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values )","title":"defaults"},{"location":"reference/spock/args/#methods_10","text":"","title":"Methods"},{"location":"reference/spock/args/#count_5","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/spock/args/#index_5","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/spock/args/#tupleoptarg","text":"class TupleOptArg ( / , * args , ** kwargs ) Spock tuple optional argument Overloads the tuple type and makes the argument optional for Spock View Source class TupleOptArg ( Tuple [ __T ] ) : # pylint : disable = too - few - public - methods \"\"\"Spock tuple optional argument Overloads the tuple type and makes the argument optional for Spock \"\"\" @staticmethod def defaults ( values : Tuple ) : \"\"\"Creates a new instance of a Spock tuple optional arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values )","title":"TupleOptArg"},{"location":"reference/spock/args/#ancestors-in-mro_11","text":"builtins.tuple typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/spock/args/#static-methods_6","text":"","title":"Static methods"},{"location":"reference/spock/args/#defaults_3","text":"def defaults ( values : Tuple ) Creates a new instance of a Spock tuple optional arg Args : values : tuple values Returns : tuple variable View Source @staticmethod def defaults ( values : Tuple ) : \"\"\"Creates a new instance of a Spock tuple optional arg *Args*: values: tuple values *Returns*: tuple variable \"\"\" return _def_tuple ( values )","title":"defaults"},{"location":"reference/spock/args/#methods_11","text":"","title":"Methods"},{"location":"reference/spock/args/#count_6","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/spock/args/#index_6","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/spock/builder/","text":"Module spock.builder Handles the building/saving of the configurations from the Spock config classes View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Handles the building/saving of the configurations from the Spock config classes\"\"\" from argparse import Namespace import argparse from pathlib import Path import sys from typing import _GenericAlias , Generic from spock._dataclasses import is_dataclass from spock.payload import Payload from spock.saver import Saver from spock.utils import cast class ConfigArgBuilder : \"\"\"Automatically generates dataclass instances from config file(s) This class builds out necessary arguments from *args dataclasses, reads the arguments from specified config file(s), and subsequently (via chained call to generate) generates each class instance based on the necessary field values for each dataclass *Attributes*: _arg_namespace: generated argument namespace _create_save_path: boolean to make the path to save to _data_classes: all of the data classes from *args _dict_args: dictionary args from the command line _optional_types: Dictionary that holds the names of types that are optional _save_path: list of path(s) to save the configs to \"\"\" def __init__ ( self , * args , ** kwargs ): self . _save_path = None self . _optional_types = { 'FloatOptArg' , 'IntOptArg' , 'StrOptArg' , 'ListOptArg' , 'TupleOptArg' , 'SavePathOptArg' } self . _data_classes = args for arg in self . _data_classes : if not is_dataclass ( arg ): raise TypeError ( '*arg inputs to ConfigArgBuilder must all be instances of @dataclass' ) self . _create_save_path = kwargs . get ( 'create_save_path' , False ) try : self . _dict_args = self . _get_payload ( ** kwargs ) self . _arg_namespace = self . _generate () except ValueError as e : self . print_usage_and_exit ( str ( e ), sys_exit = False ) raise ValueError ( e ) def print_usage_and_exit ( self , msg = None , sys_exit = True ): \"\"\"Prints the help message and exits *Args*: msg: message to print pre exit *Returns*: None \"\"\" print ( 'USAGE:' ) print ( f ' {sys.argv[0]} -c [--config] config1 [config2, config3, ...]' ) print ( 'CONFIG:' ) for data_class in self . _data_classes : print ( ' ' + data_class . __name__ + ':' ) dc_vars = vars ( data_class ) for key , val in dc_vars . get ( '__dataclass_fields__' ) . items (): if type ( val . type ) . __name__ == 'ChoiceArg' : type_name = type ( val . type ) . __name__ # Magic again -- check for type == type allows for delineation between basic types and list/tuples elif type ( val . type ) == type : type_name = val . type . __name__ else : type_name = val . type . __origin__ . __name__ type_name += '[' + self . _extract_base_type ( val . type ) . __name__ + ']' print ( f ' {key}: {type_name}' ) if msg is not None : print ( msg ) if sys_exit : sys . exit ( 1 ) def _get_config_paths ( self , ** kwargs ): \"\"\"Get config paths from all methods Config paths can enter from either the command line or be added in the class init call as a kwarg (configs=[]) *Args*: **kwargs: keyword args *Returns*: args: namespace of args \"\"\" args = self . _get_from_arg_parser ( ** kwargs ) if kwargs . get ( 'configs' ) is not None : args = self . _get_from_kwargs ( args , ** kwargs ) return args @staticmethod def _get_from_arg_parser ( ** kwargs ): \"\"\"Get configs from command line Gets the config file(s) from the command line arg parser *Args*: **kwargs: keyword args *Returns*: args: namespace of command line args \"\"\" # Pull in args via the arg parser pointing to the config file parser = argparse . ArgumentParser ( description = kwargs . get ( 'desc' ), add_help = False ) parser . add_argument ( '-c' , '--config' , required = False , nargs = '+' , default = []) parser . add_argument ( '-h' , '--help' , action = 'store_true' ) args , _ = parser . parse_known_args ( sys . argv ) return args @staticmethod def _get_from_kwargs ( args , ** kwargs ): \"\"\"Get configs from the configs kwarg *Args*: args: argument namespace **kwargs: keyword args *Returns*: args: arg namespace \"\"\" if type ( kwargs . get ( 'configs' )) . __name__ == 'list' : args . config . extend ( kwargs . get ( 'configs' )) else : raise TypeError ( 'configs kwarg must be of type list' ) return args def _get_payload ( self , ** kwargs ): \"\"\"Get the parameter payload from the config file(s) Calls the various ways to get configs and then parses to retrieve the parameter payload *Args*: **kwargs: keyword args *Returns*: payload: dictionary of parameter values \"\"\" args = self . _get_config_paths ( ** kwargs ) if args . help : self . print_usage_and_exit () payload = {} for configs in args . config : payload . update ( Payload () . payload ( self . _data_classes , configs )) return payload def __call__ ( self , * args , ** kwargs ): \"\"\"Call to self to allow chaining *Args*: *args: **kwargs: *Returns*: ConfigArgBuilder: self instance \"\"\" return ConfigArgBuilder ( * args , ** kwargs ) def _generate ( self ): \"\"\"Method to auto-generate the actual class instances from the generated args Based on the generated arguments groups and the args read in from the config file(s) this function instantiates the dataclass configs with the necessary field values *Returns*: auto_dc: namespace containing automatically generated instances of dataclasses \"\"\" auto_dc = {} for data_classes in self . _data_classes : dc_build = self . _auto_generate ( self . _dict_args , data_classes ) auto_dc . update ({ type ( dc_build ) . __name__ : dc_build }) return Namespace ( ** auto_dc ) def generate ( self ): \"\"\"Generate method that returns the actual argument namespace *Returns*: argument namespace consisting of all config classes \"\"\" return self . _arg_namespace def save ( self , user_specified_path = None , extra_info = True , file_extension = '.yaml' ): \"\"\"Saves the current config setup to file with a UUID *Args*: user_specified_path: if user provides a path it will be used as the path to write extra_info: additional info to write to saved config (run date and git info) file_extension: file type to write (default: yaml) *Returns*: self so that functions can be chained \"\"\" if user_specified_path is not None : save_path = Path ( user_specified_path ) elif self . _save_path is not None : save_path = Path ( self . _save_path ) else : raise ValueError ( 'Save did not receive a valid path from: (1) SavePathOptArg or (2) ' 'the user via user_specified_path' ) # Call the saver class and save function Saver () . save ( self . _arg_namespace , save_path , self . _create_save_path , extra_info , file_extension ) return self def _auto_generate ( self , args , data_class ): \"\"\"Builds an instance of a DataClass Builds an instance of a dataclass with the necessary field values from the argument dictionary read from the config file(s) *Args*: args: dictionary of arguments read from the config file(s) data_class: data class to build *Returns*: An instance of data_class with correct values assigned to fields \"\"\" # Handle the basic data types fields = self . _handle_basic_arguments ( args , data_class ) return data_class ( ** fields ) def _handle_basic_arguments ( self , args , data_class ): \"\"\"Handles all base types These can be easily mapped from the dataclass to another dataclass by some var inspection *Args*: args: read file arguments data_class: instance of a dataclass *Returns*: fields: dictionary of mapped parameters \"\"\" fields = {} # Access the vars dc_vars = vars ( data_class ) # Get the dataclass name dc_name = data_class . __name__ for key , val in dc_vars . get ( '__dataclass_fields__' ) . items (): # pure magic -- Lists, Tuples, etc. are not of type type (they are GenericAlias) so one must # check against this before accessing the __name__ attribute which GenericAlias does not have if type ( val . type ) == type : if val . type . __name__ == 'SavePathOptArg' : self . _save_path = args . get ( key ) # Check if namespace is named and then check for key -- checking for local def if dc_name in args and key in args [ dc_name ]: fields [ key ] = self . _check_function ( args [ dc_name ][ key ], val ) # If not named then just check for keys -- checking for global def elif key in args : fields [ key ] = self . _check_function ( args [ key ], val ) # If not found then fallback on defaults if defined else : default , found_default = self . check_for_defaults ( val ) if not found_default : if type ( val . type ) == type and val . type . __name__ in self . _optional_types : fields [ key ] = None continue elif type ( val . type ) != type and val . type . __origin__ . __name__ in self . _optional_types : fields [ key ] = None continue elif 'Bool' in val . type . __name__ : fields [ key ] = False continue else : raise ValueError ( f 'Required value {dc_name}.{key}: no default set or value defined in file' ) fields [ key ] = self . _check_function ( default , val ) return fields @staticmethod def _int_to_float ( inst , target_type ): \"\"\"Converts instance int to float *Args*: inst: instance target_type: target type *Returns*: inst: instance type cast into float \"\"\" if target_type == float and type ( inst ) == int : inst = float ( inst ) return inst def _check_function ( self , x , val ): \"\"\"Wrapper around the valid type check with a cast *Args*: x: instance val: value *Returns*: casted value \"\"\" return cast ( self . _check_valid_type ( x , val )) def _check_valid_type ( self , instance , val ): \"\"\"Checks that the instance is of the correct type *Args*: instance: object instance val: value *Returns*: instance: object instance \"\"\" if type ( val . type ) == type : # pure magic -- Lists, Tuples, etc. are not of type type (they are GenericAlias) so one must # check against this before accessing the __name__ attribute which GenericAlias does not have # Get the base variable type var_type = val . type . __bases__ [ 0 ] instance = self . _int_to_float ( instance , var_type ) valid = isinstance ( instance , var_type ) if not valid : raise ValueError ( f 'Wrong type ({type(instance)}) passed to {val.name}. Require {var_type}' ) elif type ( val . type ) . __name__ == 'ChoiceArg' : instance = self . _check_choice_type ( val . type , instance ) var_type = val . type . set_type valid = isinstance ( instance , var_type ) if not valid : raise ValueError ( f 'Wrong type ({type(instance)}) passed to {val.name}. Require {var_type}' ) else : # It's an iterable - check it's a list (only iterable provided by markup) var_type = self . _extract_base_type ( val . type ) iter_name = val . type . __origin__ . __name__ valid = isinstance ( instance , ( tuple , list )) if not valid : raise ValueError ( f 'Wrong type ({type(instance).__name__}) passed to {val.name}. \\n ' f 'Require {iter_name}[{var_type.__name__}]' ) instance = tuple (( self . _int_to_float ( i , var_type ) for i in instance )) if len ( instance ) > 0 : valid = isinstance ( instance [ 0 ], var_type ) if not valid : raise ValueError ( f 'Wrong type (List[{type(instance[0]).__name__}]) passed to {val.name}. \\n ' f 'Require {iter_name}[{var_type.__name__}]' ) return instance @staticmethod def _extract_base_type ( given_type ): \"\"\"Extracts the type from a _GenericAlias *Args*: tp: type *Returns*: tp: type of generic type \"\"\" if isinstance ( given_type , _GenericAlias ) and given_type is not Generic : return given_type . __args__ [ 0 ] # assume we only have generic types with a single argument return given_type def check_for_defaults ( self , val ): \"\"\"Checks for default values *Args*: default: default value default_factory: default factory *Returns*: default_val: value of default found_default: boolean if default found \"\"\" found_default = False default_val = None if type ( val . type ) . __name__ == 'ChoiceArg' : default_val = self . _check_choice_type ( val . type , val . type . default ) found_default = True elif type ( val . default ) . __name__ != '_MISSING_TYPE' : default_val = val . default found_default = True elif type ( val . default_factory ) . __name__ != '_MISSING_TYPE' : default_val = val . default_factory () found_default = True return default_val , found_default @staticmethod def _check_choice_type ( choice_set , val ): \"\"\"Checks the type and set of a ChoiceArg value *Args*: choice_set: ChoiceArg instance val: value to set val_name: name of the parameter *Returns*: val: value to set \"\"\" if val not in choice_set . choice_set : raise ValueError ( f '{val} is not within the set of defined choices {choice_set.choice_set}' ) return val Classes ConfigArgBuilder class ConfigArgBuilder ( * args , ** kwargs ) Automatically generates dataclass instances from config file(s) This class builds out necessary arguments from *args dataclasses, reads the arguments from specified config file(s), and subsequently (via chained call to generate) generates each class instance based on the necessary field values for each dataclass Attributes : _arg_namespace : generated argument namespace _create_save_path : boolean to make the path to save to _data_classes : all of the data classes from * args _dict_args : dictionary args from the command line _optional_types : Dictionary that holds the names of types that are optional _save_path : list of path ( s ) to save the configs to View Source class ConfigArgBuilder : \"\"\"Automatically generates dataclass instances from config file(s) This class builds out necessary arguments from *args dataclasses, reads the arguments from specified config file(s), and subsequently (via chained call to generate) generates each class instance based on the necessary field values for each dataclass *Attributes*: _arg_namespace: generated argument namespace _create_save_path: boolean to make the path to save to _data_classes: all of the data classes from *args _dict_args: dictionary args from the command line _optional_types: Dictionary that holds the names of types that are optional _save_path: list of path(s) to save the configs to \"\"\" def __init__ ( self , * args , ** kwargs ) : self . _save_path = None self . _optional_types = { 'FloatOptArg' , 'IntOptArg' , 'StrOptArg' , 'ListOptArg' , 'TupleOptArg' , 'SavePathOptArg' } self . _data_classes = args for arg in self . _data_classes : if not is_dataclass ( arg ) : raise TypeError ( '*arg inputs to ConfigArgBuilder must all be instances of @dataclass' ) self . _create_save_path = kwargs . get ( 'create_save_path' , False ) try : self . _dict_args = self . _get_payload ( ** kwargs ) self . _arg_namespace = self . _generate () except ValueError as e : self . print_usage_and_exit ( str ( e ), sys_exit = False ) raise ValueError ( e ) def print_usage_and_exit ( self , msg = None , sys_exit = True ) : \"\"\"Prints the help message and exits *Args*: msg: message to print pre exit *Returns*: None \"\"\" print ( 'USAGE:' ) print ( f ' {sys.argv[0]} -c [--config] config1 [config2, config3, ...]' ) print ( 'CONFIG:' ) for data_class in self . _data_classes : print ( ' ' + data_class . __name__ + ':' ) dc_vars = vars ( data_class ) for key , val in dc_vars . get ( '__dataclass_fields__' ). items () : if type ( val . type ). __name__ == 'ChoiceArg' : type_name = type ( val . type ). __name__ # Magic again -- check for type == type allows for delineation between basic types and list/tuples elif type ( val . type ) == type : type_name = val . type . __name__ else : type_name = val . type . __origin__ . __name__ type_name += '[' + self . _extract_base_type ( val . type ). __name__ + ']' print ( f ' {key}: {type_name}' ) if msg is not None : print ( msg ) if sys_exit : sys . exit ( 1 ) def _get_config_paths ( self , ** kwargs ) : \"\"\"Get config paths from all methods Config paths can enter from either the command line or be added in the class init call as a kwarg (configs=[]) *Args*: **kwargs: keyword args *Returns*: args: namespace of args \"\"\" args = self . _get_from_arg_parser ( ** kwargs ) if kwargs . get ( 'configs' ) is not None : args = self . _get_from_kwargs ( args , ** kwargs ) return args @staticmethod def _get_from_arg_parser ( ** kwargs ) : \"\"\"Get configs from command line Gets the config file(s) from the command line arg parser *Args*: **kwargs: keyword args *Returns*: args: namespace of command line args \"\"\" # Pull in args via the arg parser pointing to the config file parser = argparse . ArgumentParser ( description = kwargs . get ( 'desc' ), add_help = False ) parser . add_argument ( '-c' , '--config' , required = False , nargs = '+' , default = [] ) parser . add_argument ( '-h' , '--help' , action = 'store_true' ) args , _ = parser . parse_known_args ( sys . argv ) return args @staticmethod def _get_from_kwargs ( args , ** kwargs ) : \"\"\"Get configs from the configs kwarg *Args*: args: argument namespace **kwargs: keyword args *Returns*: args: arg namespace \"\"\" if type ( kwargs . get ( 'configs' )). __name__ == 'list' : args . config . extend ( kwargs . get ( 'configs' )) else : raise TypeError ( 'configs kwarg must be of type list' ) return args def _get_payload ( self , ** kwargs ) : \"\"\"Get the parameter payload from the config file(s) Calls the various ways to get configs and then parses to retrieve the parameter payload *Args*: **kwargs: keyword args *Returns*: payload: dictionary of parameter values \"\"\" args = self . _get_config_paths ( ** kwargs ) if args . help : self . print_usage_and_exit () payload = {} for configs in args . config : payload . update ( Payload (). payload ( self . _data_classes , configs )) return payload def __call__ ( self , * args , ** kwargs ) : \"\"\"Call to self to allow chaining *Args*: *args: **kwargs: *Returns*: ConfigArgBuilder: self instance \"\"\" return ConfigArgBuilder ( * args , ** kwargs ) def _generate ( self ) : \"\"\"Method to auto-generate the actual class instances from the generated args Based on the generated arguments groups and the args read in from the config file(s) this function instantiates the dataclass configs with the necessary field values *Returns*: auto_dc: namespace containing automatically generated instances of dataclasses \"\"\" auto_dc = {} for data_classes in self . _data_classes : dc_build = self . _auto_generate ( self . _dict_args , data_classes ) auto_dc . update ( { type ( dc_build ). __name__ : dc_build } ) return Namespace ( ** auto_dc ) def generate ( self ) : \"\"\"Generate method that returns the actual argument namespace *Returns*: argument namespace consisting of all config classes \"\"\" return self . _arg_namespace def save ( self , user_specified_path = None , extra_info = True , file_extension = '.yaml' ) : \"\"\"Saves the current config setup to file with a UUID *Args*: user_specified_path: if user provides a path it will be used as the path to write extra_info: additional info to write to saved config (run date and git info) file_extension: file type to write (default: yaml) *Returns*: self so that functions can be chained \"\"\" if user_specified_path is not None : save_path = Path ( user_specified_path ) elif self . _save_path is not None : save_path = Path ( self . _save_path ) else : raise ValueError ( 'Save did not receive a valid path from: (1) SavePathOptArg or (2) ' 'the user via user_specified_path' ) # Call the saver class and save function Saver (). save ( self . _arg_namespace , save_path , self . _create_save_path , extra_info , file_extension ) return self def _auto_generate ( self , args , data_class ) : \"\"\"Builds an instance of a DataClass Builds an instance of a dataclass with the necessary field values from the argument dictionary read from the config file(s) *Args*: args: dictionary of arguments read from the config file(s) data_class: data class to build *Returns*: An instance of data_class with correct values assigned to fields \"\"\" # Handle the basic data types fields = self . _handle_basic_arguments ( args , data_class ) return data_class ( ** fields ) def _handle_basic_arguments ( self , args , data_class ) : \"\"\"Handles all base types These can be easily mapped from the dataclass to another dataclass by some var inspection *Args*: args: read file arguments data_class: instance of a dataclass *Returns*: fields: dictionary of mapped parameters \"\"\" fields = {} # Access the vars dc_vars = vars ( data_class ) # Get the dataclass name dc_name = data_class . __name__ for key , val in dc_vars . get ( '__dataclass_fields__' ). items () : # pure magic -- Lists, Tuples, etc. are not of type type (they are GenericAlias) so one must # check against this before accessing the __name__ attribute which GenericAlias does not have if type ( val . type ) == type : if val . type . __name__ == 'SavePathOptArg' : self . _save_path = args . get ( key ) # Check if namespace is named and then check for key -- checking for local def if dc_name in args and key in args [ dc_name ] : fields [ key ] = self . _check_function ( args [ dc_name ][ key ] , val ) # If not named then just check for keys -- checking for global def elif key in args : fields [ key ] = self . _check_function ( args [ key ] , val ) # If not found then fallback on defaults if defined else : default , found_default = self . check_for_defaults ( val ) if not found_default : if type ( val . type ) == type and val . type . __name__ in self . _optional_types : fields [ key ] = None continue elif type ( val . type ) != type and val . type . __origin__ . __name__ in self . _optional_types : fields [ key ] = None continue elif 'Bool' in val . type . __name__ : fields [ key ] = False continue else : raise ValueError ( f 'Required value {dc_name}.{key}: no default set or value defined in file' ) fields [ key ] = self . _check_function ( default , val ) return fields @staticmethod def _int_to_float ( inst , target_type ) : \"\"\"Converts instance int to float *Args*: inst: instance target_type: target type *Returns*: inst: instance type cast into float \"\"\" if target_type == float and type ( inst ) == int : inst = float ( inst ) return inst def _check_function ( self , x , val ) : \"\"\"Wrapper around the valid type check with a cast *Args*: x: instance val: value *Returns*: casted value \"\"\" return cast ( self . _check_valid_type ( x , val )) def _check_valid_type ( self , instance , val ) : \"\"\"Checks that the instance is of the correct type *Args*: instance: object instance val: value *Returns*: instance: object instance \"\"\" if type ( val . type ) == type : # pure magic -- Lists, Tuples, etc. are not of type type (they are GenericAlias) so one must # check against this before accessing the __name__ attribute which GenericAlias does not have # Get the base variable type var_type = val . type . __bases__ [ 0 ] instance = self . _int_to_float ( instance , var_type ) valid = isinstance ( instance , var_type ) if not valid : raise ValueError ( f 'Wrong type ({type(instance)}) passed to {val.name}. Require {var_type}' ) elif type ( val . type ). __name__ == 'ChoiceArg' : instance = self . _check_choice_type ( val . type , instance ) var_type = val . type . set_type valid = isinstance ( instance , var_type ) if not valid : raise ValueError ( f 'Wrong type ({type(instance)}) passed to {val.name}. Require {var_type}' ) else : # It 's an iterable - check it' s a list ( only iterable provided by markup ) var_type = self . _extract_base_type ( val . type ) iter_name = val . type . __origin__ . __name__ valid = isinstance ( instance , ( tuple , list )) if not valid : raise ValueError ( f 'Wrong type ({type(instance).__name__}) passed to {val.name}.\\n' f 'Require {iter_name}[{var_type.__name__}]' ) instance = tuple (( self . _int_to_float ( i , var_type ) for i in instance )) if len ( instance ) > 0 : valid = isinstance ( instance [ 0 ] , var_type ) if not valid : raise ValueError ( f 'Wrong type (List[{type(instance[0]).__name__}]) passed to {val.name}.\\n' f 'Require {iter_name}[{var_type.__name__}]' ) return instance @staticmethod def _extract_base_type ( given_type ) : \"\"\"Extracts the type from a _GenericAlias *Args*: tp: type *Returns*: tp: type of generic type \"\"\" if isinstance ( given_type , _GenericAlias ) and given_type is not Generic : return given_type . __args__ [ 0 ] # assume we only have generic types with a single argument return given_type def check_for_defaults ( self , val ) : \"\"\"Checks for default values *Args*: default: default value default_factory: default factory *Returns*: default_val: value of default found_default: boolean if default found \"\"\" found_default = False default_val = None if type ( val . type ). __name__ == 'ChoiceArg' : default_val = self . _check_choice_type ( val . type , val . type . default ) found_default = True elif type ( val . default ). __name__ != '_MISSING_TYPE' : default_val = val . default found_default = True elif type ( val . default_factory ). __name__ != '_MISSING_TYPE' : default_val = val . default_factory () found_default = True return default_val , found_default @staticmethod def _check_choice_type ( choice_set , val ) : \"\"\"Checks the type and set of a ChoiceArg value *Args*: choice_set: ChoiceArg instance val: value to set val_name: name of the parameter *Returns*: val: value to set \"\"\" if val not in choice_set . choice_set : raise ValueError ( f '{val} is not within the set of defined choices {choice_set.choice_set}' ) return val Methods check_for_defaults def check_for_defaults ( self , val ) Checks for default values Args : default : default value default_factory : default factory Returns : default_val : value of default found_default : boolean if default found View Source def check_for_defaults ( self , val ): \"\"\"Checks for default values *Args*: default: default value default_factory: default factory *Returns*: default_val: value of default found_default: boolean if default found \"\"\" found_default = False default_val = None if type ( val . type ). __name__ == 'ChoiceArg' : default_val = self . _check_choice_type ( val . type , val . type . default ) found_default = True elif type ( val . default ). __name__ != '_MISSING_TYPE' : default_val = val . default found_default = True elif type ( val . default_factory ). __name__ != '_MISSING_TYPE' : default_val = val . default_factory () found_default = True return default_val , found_default generate def generate ( self ) Generate method that returns the actual argument namespace Returns : argument namespace consisting of all config classes View Source def generate ( self ): \"\"\"Generate method that returns the actual argument namespace *Returns*: argument namespace consisting of all config classes \"\"\" return self . _arg_namespace print_usage_and_exit def print_usage_and_exit ( self , msg = None , sys_exit = True ) Prints the help message and exits Args : msg : message to print pre exit Returns : None View Source def print_usage_and_exit ( self , msg= None , sys_exit= True ): \"\"\"Prints the help message and exits *Args*: msg: message to print pre exit *Returns*: None \"\"\" print ( ' USAGE:' ) print ( f' { sys . argv [ 0 ]} - c [ -- config ] config1 [ config2 , config3 , ... ] ' ) print ( ' CONFIG:' ) for data_class in self . _data_classes : print ( ' ' + data_class . __name__ + ' : ' ) dc_vars = vars ( data_class ) for key , val in dc_vars . get ( ' __dataclass_fields__' ) . items (): if type ( val . type ) . __name__ = = ' ChoiceArg' : type_name = type ( val . type ) . __name__ # Magic again -- check for type == type allows for delineation between basic types and list/tuples elif type ( val . type ) == type : type_name = val . type . __name__ else : type_name = val . type . __origin__ . __name__ type_name += ' [ ' + self . _extract_base_type ( val . type ) . __name__ + ' ] ' print ( f' { key }: { type_name } ' ) if msg is not None : print ( msg ) if sys_exit : sys . exit ( 1 ) save def save ( self , user_specified_path = None , extra_info = True , file_extension = '.yaml' ) Saves the current config setup to file with a UUID Args : user_specified_path : if user provides a path it will be used as the path to write extra_info : additional info to write to saved config ( run date and git info ) file_extension : file type to write ( default : yaml ) Returns : self so that functions can be chained View Source def save ( self , user_specified_path = None , extra_info = True , file_extension = '.yaml' ): \"\"\"Saves the current config setup to file with a UUID *Args*: user_specified_path: if user provides a path it will be used as the path to write extra_info: additional info to write to saved config (run date and git info) file_extension: file type to write (default: yaml) *Returns*: self so that functions can be chained \"\"\" if user_specified_path is not None : save_path = Path ( user_specified_path ) elif self . _save_path is not None : save_path = Path ( self . _save_path ) else : raise ValueError ( 'Save did not receive a valid path from: (1) SavePathOptArg or (2) ' 'the user via user_specified_path' ) # Call the saver class and save function Saver (). save ( self . _arg_namespace , save_path , self . _create_save_path , extra_info , file_extension ) return self","title":"Builder"},{"location":"reference/spock/builder/#module-spockbuilder","text":"Handles the building/saving of the configurations from the Spock config classes View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Handles the building/saving of the configurations from the Spock config classes\"\"\" from argparse import Namespace import argparse from pathlib import Path import sys from typing import _GenericAlias , Generic from spock._dataclasses import is_dataclass from spock.payload import Payload from spock.saver import Saver from spock.utils import cast class ConfigArgBuilder : \"\"\"Automatically generates dataclass instances from config file(s) This class builds out necessary arguments from *args dataclasses, reads the arguments from specified config file(s), and subsequently (via chained call to generate) generates each class instance based on the necessary field values for each dataclass *Attributes*: _arg_namespace: generated argument namespace _create_save_path: boolean to make the path to save to _data_classes: all of the data classes from *args _dict_args: dictionary args from the command line _optional_types: Dictionary that holds the names of types that are optional _save_path: list of path(s) to save the configs to \"\"\" def __init__ ( self , * args , ** kwargs ): self . _save_path = None self . _optional_types = { 'FloatOptArg' , 'IntOptArg' , 'StrOptArg' , 'ListOptArg' , 'TupleOptArg' , 'SavePathOptArg' } self . _data_classes = args for arg in self . _data_classes : if not is_dataclass ( arg ): raise TypeError ( '*arg inputs to ConfigArgBuilder must all be instances of @dataclass' ) self . _create_save_path = kwargs . get ( 'create_save_path' , False ) try : self . _dict_args = self . _get_payload ( ** kwargs ) self . _arg_namespace = self . _generate () except ValueError as e : self . print_usage_and_exit ( str ( e ), sys_exit = False ) raise ValueError ( e ) def print_usage_and_exit ( self , msg = None , sys_exit = True ): \"\"\"Prints the help message and exits *Args*: msg: message to print pre exit *Returns*: None \"\"\" print ( 'USAGE:' ) print ( f ' {sys.argv[0]} -c [--config] config1 [config2, config3, ...]' ) print ( 'CONFIG:' ) for data_class in self . _data_classes : print ( ' ' + data_class . __name__ + ':' ) dc_vars = vars ( data_class ) for key , val in dc_vars . get ( '__dataclass_fields__' ) . items (): if type ( val . type ) . __name__ == 'ChoiceArg' : type_name = type ( val . type ) . __name__ # Magic again -- check for type == type allows for delineation between basic types and list/tuples elif type ( val . type ) == type : type_name = val . type . __name__ else : type_name = val . type . __origin__ . __name__ type_name += '[' + self . _extract_base_type ( val . type ) . __name__ + ']' print ( f ' {key}: {type_name}' ) if msg is not None : print ( msg ) if sys_exit : sys . exit ( 1 ) def _get_config_paths ( self , ** kwargs ): \"\"\"Get config paths from all methods Config paths can enter from either the command line or be added in the class init call as a kwarg (configs=[]) *Args*: **kwargs: keyword args *Returns*: args: namespace of args \"\"\" args = self . _get_from_arg_parser ( ** kwargs ) if kwargs . get ( 'configs' ) is not None : args = self . _get_from_kwargs ( args , ** kwargs ) return args @staticmethod def _get_from_arg_parser ( ** kwargs ): \"\"\"Get configs from command line Gets the config file(s) from the command line arg parser *Args*: **kwargs: keyword args *Returns*: args: namespace of command line args \"\"\" # Pull in args via the arg parser pointing to the config file parser = argparse . ArgumentParser ( description = kwargs . get ( 'desc' ), add_help = False ) parser . add_argument ( '-c' , '--config' , required = False , nargs = '+' , default = []) parser . add_argument ( '-h' , '--help' , action = 'store_true' ) args , _ = parser . parse_known_args ( sys . argv ) return args @staticmethod def _get_from_kwargs ( args , ** kwargs ): \"\"\"Get configs from the configs kwarg *Args*: args: argument namespace **kwargs: keyword args *Returns*: args: arg namespace \"\"\" if type ( kwargs . get ( 'configs' )) . __name__ == 'list' : args . config . extend ( kwargs . get ( 'configs' )) else : raise TypeError ( 'configs kwarg must be of type list' ) return args def _get_payload ( self , ** kwargs ): \"\"\"Get the parameter payload from the config file(s) Calls the various ways to get configs and then parses to retrieve the parameter payload *Args*: **kwargs: keyword args *Returns*: payload: dictionary of parameter values \"\"\" args = self . _get_config_paths ( ** kwargs ) if args . help : self . print_usage_and_exit () payload = {} for configs in args . config : payload . update ( Payload () . payload ( self . _data_classes , configs )) return payload def __call__ ( self , * args , ** kwargs ): \"\"\"Call to self to allow chaining *Args*: *args: **kwargs: *Returns*: ConfigArgBuilder: self instance \"\"\" return ConfigArgBuilder ( * args , ** kwargs ) def _generate ( self ): \"\"\"Method to auto-generate the actual class instances from the generated args Based on the generated arguments groups and the args read in from the config file(s) this function instantiates the dataclass configs with the necessary field values *Returns*: auto_dc: namespace containing automatically generated instances of dataclasses \"\"\" auto_dc = {} for data_classes in self . _data_classes : dc_build = self . _auto_generate ( self . _dict_args , data_classes ) auto_dc . update ({ type ( dc_build ) . __name__ : dc_build }) return Namespace ( ** auto_dc ) def generate ( self ): \"\"\"Generate method that returns the actual argument namespace *Returns*: argument namespace consisting of all config classes \"\"\" return self . _arg_namespace def save ( self , user_specified_path = None , extra_info = True , file_extension = '.yaml' ): \"\"\"Saves the current config setup to file with a UUID *Args*: user_specified_path: if user provides a path it will be used as the path to write extra_info: additional info to write to saved config (run date and git info) file_extension: file type to write (default: yaml) *Returns*: self so that functions can be chained \"\"\" if user_specified_path is not None : save_path = Path ( user_specified_path ) elif self . _save_path is not None : save_path = Path ( self . _save_path ) else : raise ValueError ( 'Save did not receive a valid path from: (1) SavePathOptArg or (2) ' 'the user via user_specified_path' ) # Call the saver class and save function Saver () . save ( self . _arg_namespace , save_path , self . _create_save_path , extra_info , file_extension ) return self def _auto_generate ( self , args , data_class ): \"\"\"Builds an instance of a DataClass Builds an instance of a dataclass with the necessary field values from the argument dictionary read from the config file(s) *Args*: args: dictionary of arguments read from the config file(s) data_class: data class to build *Returns*: An instance of data_class with correct values assigned to fields \"\"\" # Handle the basic data types fields = self . _handle_basic_arguments ( args , data_class ) return data_class ( ** fields ) def _handle_basic_arguments ( self , args , data_class ): \"\"\"Handles all base types These can be easily mapped from the dataclass to another dataclass by some var inspection *Args*: args: read file arguments data_class: instance of a dataclass *Returns*: fields: dictionary of mapped parameters \"\"\" fields = {} # Access the vars dc_vars = vars ( data_class ) # Get the dataclass name dc_name = data_class . __name__ for key , val in dc_vars . get ( '__dataclass_fields__' ) . items (): # pure magic -- Lists, Tuples, etc. are not of type type (they are GenericAlias) so one must # check against this before accessing the __name__ attribute which GenericAlias does not have if type ( val . type ) == type : if val . type . __name__ == 'SavePathOptArg' : self . _save_path = args . get ( key ) # Check if namespace is named and then check for key -- checking for local def if dc_name in args and key in args [ dc_name ]: fields [ key ] = self . _check_function ( args [ dc_name ][ key ], val ) # If not named then just check for keys -- checking for global def elif key in args : fields [ key ] = self . _check_function ( args [ key ], val ) # If not found then fallback on defaults if defined else : default , found_default = self . check_for_defaults ( val ) if not found_default : if type ( val . type ) == type and val . type . __name__ in self . _optional_types : fields [ key ] = None continue elif type ( val . type ) != type and val . type . __origin__ . __name__ in self . _optional_types : fields [ key ] = None continue elif 'Bool' in val . type . __name__ : fields [ key ] = False continue else : raise ValueError ( f 'Required value {dc_name}.{key}: no default set or value defined in file' ) fields [ key ] = self . _check_function ( default , val ) return fields @staticmethod def _int_to_float ( inst , target_type ): \"\"\"Converts instance int to float *Args*: inst: instance target_type: target type *Returns*: inst: instance type cast into float \"\"\" if target_type == float and type ( inst ) == int : inst = float ( inst ) return inst def _check_function ( self , x , val ): \"\"\"Wrapper around the valid type check with a cast *Args*: x: instance val: value *Returns*: casted value \"\"\" return cast ( self . _check_valid_type ( x , val )) def _check_valid_type ( self , instance , val ): \"\"\"Checks that the instance is of the correct type *Args*: instance: object instance val: value *Returns*: instance: object instance \"\"\" if type ( val . type ) == type : # pure magic -- Lists, Tuples, etc. are not of type type (they are GenericAlias) so one must # check against this before accessing the __name__ attribute which GenericAlias does not have # Get the base variable type var_type = val . type . __bases__ [ 0 ] instance = self . _int_to_float ( instance , var_type ) valid = isinstance ( instance , var_type ) if not valid : raise ValueError ( f 'Wrong type ({type(instance)}) passed to {val.name}. Require {var_type}' ) elif type ( val . type ) . __name__ == 'ChoiceArg' : instance = self . _check_choice_type ( val . type , instance ) var_type = val . type . set_type valid = isinstance ( instance , var_type ) if not valid : raise ValueError ( f 'Wrong type ({type(instance)}) passed to {val.name}. Require {var_type}' ) else : # It's an iterable - check it's a list (only iterable provided by markup) var_type = self . _extract_base_type ( val . type ) iter_name = val . type . __origin__ . __name__ valid = isinstance ( instance , ( tuple , list )) if not valid : raise ValueError ( f 'Wrong type ({type(instance).__name__}) passed to {val.name}. \\n ' f 'Require {iter_name}[{var_type.__name__}]' ) instance = tuple (( self . _int_to_float ( i , var_type ) for i in instance )) if len ( instance ) > 0 : valid = isinstance ( instance [ 0 ], var_type ) if not valid : raise ValueError ( f 'Wrong type (List[{type(instance[0]).__name__}]) passed to {val.name}. \\n ' f 'Require {iter_name}[{var_type.__name__}]' ) return instance @staticmethod def _extract_base_type ( given_type ): \"\"\"Extracts the type from a _GenericAlias *Args*: tp: type *Returns*: tp: type of generic type \"\"\" if isinstance ( given_type , _GenericAlias ) and given_type is not Generic : return given_type . __args__ [ 0 ] # assume we only have generic types with a single argument return given_type def check_for_defaults ( self , val ): \"\"\"Checks for default values *Args*: default: default value default_factory: default factory *Returns*: default_val: value of default found_default: boolean if default found \"\"\" found_default = False default_val = None if type ( val . type ) . __name__ == 'ChoiceArg' : default_val = self . _check_choice_type ( val . type , val . type . default ) found_default = True elif type ( val . default ) . __name__ != '_MISSING_TYPE' : default_val = val . default found_default = True elif type ( val . default_factory ) . __name__ != '_MISSING_TYPE' : default_val = val . default_factory () found_default = True return default_val , found_default @staticmethod def _check_choice_type ( choice_set , val ): \"\"\"Checks the type and set of a ChoiceArg value *Args*: choice_set: ChoiceArg instance val: value to set val_name: name of the parameter *Returns*: val: value to set \"\"\" if val not in choice_set . choice_set : raise ValueError ( f '{val} is not within the set of defined choices {choice_set.choice_set}' ) return val","title":"Module spock.builder"},{"location":"reference/spock/builder/#classes","text":"","title":"Classes"},{"location":"reference/spock/builder/#configargbuilder","text":"class ConfigArgBuilder ( * args , ** kwargs ) Automatically generates dataclass instances from config file(s) This class builds out necessary arguments from *args dataclasses, reads the arguments from specified config file(s), and subsequently (via chained call to generate) generates each class instance based on the necessary field values for each dataclass Attributes : _arg_namespace : generated argument namespace _create_save_path : boolean to make the path to save to _data_classes : all of the data classes from * args _dict_args : dictionary args from the command line _optional_types : Dictionary that holds the names of types that are optional _save_path : list of path ( s ) to save the configs to View Source class ConfigArgBuilder : \"\"\"Automatically generates dataclass instances from config file(s) This class builds out necessary arguments from *args dataclasses, reads the arguments from specified config file(s), and subsequently (via chained call to generate) generates each class instance based on the necessary field values for each dataclass *Attributes*: _arg_namespace: generated argument namespace _create_save_path: boolean to make the path to save to _data_classes: all of the data classes from *args _dict_args: dictionary args from the command line _optional_types: Dictionary that holds the names of types that are optional _save_path: list of path(s) to save the configs to \"\"\" def __init__ ( self , * args , ** kwargs ) : self . _save_path = None self . _optional_types = { 'FloatOptArg' , 'IntOptArg' , 'StrOptArg' , 'ListOptArg' , 'TupleOptArg' , 'SavePathOptArg' } self . _data_classes = args for arg in self . _data_classes : if not is_dataclass ( arg ) : raise TypeError ( '*arg inputs to ConfigArgBuilder must all be instances of @dataclass' ) self . _create_save_path = kwargs . get ( 'create_save_path' , False ) try : self . _dict_args = self . _get_payload ( ** kwargs ) self . _arg_namespace = self . _generate () except ValueError as e : self . print_usage_and_exit ( str ( e ), sys_exit = False ) raise ValueError ( e ) def print_usage_and_exit ( self , msg = None , sys_exit = True ) : \"\"\"Prints the help message and exits *Args*: msg: message to print pre exit *Returns*: None \"\"\" print ( 'USAGE:' ) print ( f ' {sys.argv[0]} -c [--config] config1 [config2, config3, ...]' ) print ( 'CONFIG:' ) for data_class in self . _data_classes : print ( ' ' + data_class . __name__ + ':' ) dc_vars = vars ( data_class ) for key , val in dc_vars . get ( '__dataclass_fields__' ). items () : if type ( val . type ). __name__ == 'ChoiceArg' : type_name = type ( val . type ). __name__ # Magic again -- check for type == type allows for delineation between basic types and list/tuples elif type ( val . type ) == type : type_name = val . type . __name__ else : type_name = val . type . __origin__ . __name__ type_name += '[' + self . _extract_base_type ( val . type ). __name__ + ']' print ( f ' {key}: {type_name}' ) if msg is not None : print ( msg ) if sys_exit : sys . exit ( 1 ) def _get_config_paths ( self , ** kwargs ) : \"\"\"Get config paths from all methods Config paths can enter from either the command line or be added in the class init call as a kwarg (configs=[]) *Args*: **kwargs: keyword args *Returns*: args: namespace of args \"\"\" args = self . _get_from_arg_parser ( ** kwargs ) if kwargs . get ( 'configs' ) is not None : args = self . _get_from_kwargs ( args , ** kwargs ) return args @staticmethod def _get_from_arg_parser ( ** kwargs ) : \"\"\"Get configs from command line Gets the config file(s) from the command line arg parser *Args*: **kwargs: keyword args *Returns*: args: namespace of command line args \"\"\" # Pull in args via the arg parser pointing to the config file parser = argparse . ArgumentParser ( description = kwargs . get ( 'desc' ), add_help = False ) parser . add_argument ( '-c' , '--config' , required = False , nargs = '+' , default = [] ) parser . add_argument ( '-h' , '--help' , action = 'store_true' ) args , _ = parser . parse_known_args ( sys . argv ) return args @staticmethod def _get_from_kwargs ( args , ** kwargs ) : \"\"\"Get configs from the configs kwarg *Args*: args: argument namespace **kwargs: keyword args *Returns*: args: arg namespace \"\"\" if type ( kwargs . get ( 'configs' )). __name__ == 'list' : args . config . extend ( kwargs . get ( 'configs' )) else : raise TypeError ( 'configs kwarg must be of type list' ) return args def _get_payload ( self , ** kwargs ) : \"\"\"Get the parameter payload from the config file(s) Calls the various ways to get configs and then parses to retrieve the parameter payload *Args*: **kwargs: keyword args *Returns*: payload: dictionary of parameter values \"\"\" args = self . _get_config_paths ( ** kwargs ) if args . help : self . print_usage_and_exit () payload = {} for configs in args . config : payload . update ( Payload (). payload ( self . _data_classes , configs )) return payload def __call__ ( self , * args , ** kwargs ) : \"\"\"Call to self to allow chaining *Args*: *args: **kwargs: *Returns*: ConfigArgBuilder: self instance \"\"\" return ConfigArgBuilder ( * args , ** kwargs ) def _generate ( self ) : \"\"\"Method to auto-generate the actual class instances from the generated args Based on the generated arguments groups and the args read in from the config file(s) this function instantiates the dataclass configs with the necessary field values *Returns*: auto_dc: namespace containing automatically generated instances of dataclasses \"\"\" auto_dc = {} for data_classes in self . _data_classes : dc_build = self . _auto_generate ( self . _dict_args , data_classes ) auto_dc . update ( { type ( dc_build ). __name__ : dc_build } ) return Namespace ( ** auto_dc ) def generate ( self ) : \"\"\"Generate method that returns the actual argument namespace *Returns*: argument namespace consisting of all config classes \"\"\" return self . _arg_namespace def save ( self , user_specified_path = None , extra_info = True , file_extension = '.yaml' ) : \"\"\"Saves the current config setup to file with a UUID *Args*: user_specified_path: if user provides a path it will be used as the path to write extra_info: additional info to write to saved config (run date and git info) file_extension: file type to write (default: yaml) *Returns*: self so that functions can be chained \"\"\" if user_specified_path is not None : save_path = Path ( user_specified_path ) elif self . _save_path is not None : save_path = Path ( self . _save_path ) else : raise ValueError ( 'Save did not receive a valid path from: (1) SavePathOptArg or (2) ' 'the user via user_specified_path' ) # Call the saver class and save function Saver (). save ( self . _arg_namespace , save_path , self . _create_save_path , extra_info , file_extension ) return self def _auto_generate ( self , args , data_class ) : \"\"\"Builds an instance of a DataClass Builds an instance of a dataclass with the necessary field values from the argument dictionary read from the config file(s) *Args*: args: dictionary of arguments read from the config file(s) data_class: data class to build *Returns*: An instance of data_class with correct values assigned to fields \"\"\" # Handle the basic data types fields = self . _handle_basic_arguments ( args , data_class ) return data_class ( ** fields ) def _handle_basic_arguments ( self , args , data_class ) : \"\"\"Handles all base types These can be easily mapped from the dataclass to another dataclass by some var inspection *Args*: args: read file arguments data_class: instance of a dataclass *Returns*: fields: dictionary of mapped parameters \"\"\" fields = {} # Access the vars dc_vars = vars ( data_class ) # Get the dataclass name dc_name = data_class . __name__ for key , val in dc_vars . get ( '__dataclass_fields__' ). items () : # pure magic -- Lists, Tuples, etc. are not of type type (they are GenericAlias) so one must # check against this before accessing the __name__ attribute which GenericAlias does not have if type ( val . type ) == type : if val . type . __name__ == 'SavePathOptArg' : self . _save_path = args . get ( key ) # Check if namespace is named and then check for key -- checking for local def if dc_name in args and key in args [ dc_name ] : fields [ key ] = self . _check_function ( args [ dc_name ][ key ] , val ) # If not named then just check for keys -- checking for global def elif key in args : fields [ key ] = self . _check_function ( args [ key ] , val ) # If not found then fallback on defaults if defined else : default , found_default = self . check_for_defaults ( val ) if not found_default : if type ( val . type ) == type and val . type . __name__ in self . _optional_types : fields [ key ] = None continue elif type ( val . type ) != type and val . type . __origin__ . __name__ in self . _optional_types : fields [ key ] = None continue elif 'Bool' in val . type . __name__ : fields [ key ] = False continue else : raise ValueError ( f 'Required value {dc_name}.{key}: no default set or value defined in file' ) fields [ key ] = self . _check_function ( default , val ) return fields @staticmethod def _int_to_float ( inst , target_type ) : \"\"\"Converts instance int to float *Args*: inst: instance target_type: target type *Returns*: inst: instance type cast into float \"\"\" if target_type == float and type ( inst ) == int : inst = float ( inst ) return inst def _check_function ( self , x , val ) : \"\"\"Wrapper around the valid type check with a cast *Args*: x: instance val: value *Returns*: casted value \"\"\" return cast ( self . _check_valid_type ( x , val )) def _check_valid_type ( self , instance , val ) : \"\"\"Checks that the instance is of the correct type *Args*: instance: object instance val: value *Returns*: instance: object instance \"\"\" if type ( val . type ) == type : # pure magic -- Lists, Tuples, etc. are not of type type (they are GenericAlias) so one must # check against this before accessing the __name__ attribute which GenericAlias does not have # Get the base variable type var_type = val . type . __bases__ [ 0 ] instance = self . _int_to_float ( instance , var_type ) valid = isinstance ( instance , var_type ) if not valid : raise ValueError ( f 'Wrong type ({type(instance)}) passed to {val.name}. Require {var_type}' ) elif type ( val . type ). __name__ == 'ChoiceArg' : instance = self . _check_choice_type ( val . type , instance ) var_type = val . type . set_type valid = isinstance ( instance , var_type ) if not valid : raise ValueError ( f 'Wrong type ({type(instance)}) passed to {val.name}. Require {var_type}' ) else : # It 's an iterable - check it' s a list ( only iterable provided by markup ) var_type = self . _extract_base_type ( val . type ) iter_name = val . type . __origin__ . __name__ valid = isinstance ( instance , ( tuple , list )) if not valid : raise ValueError ( f 'Wrong type ({type(instance).__name__}) passed to {val.name}.\\n' f 'Require {iter_name}[{var_type.__name__}]' ) instance = tuple (( self . _int_to_float ( i , var_type ) for i in instance )) if len ( instance ) > 0 : valid = isinstance ( instance [ 0 ] , var_type ) if not valid : raise ValueError ( f 'Wrong type (List[{type(instance[0]).__name__}]) passed to {val.name}.\\n' f 'Require {iter_name}[{var_type.__name__}]' ) return instance @staticmethod def _extract_base_type ( given_type ) : \"\"\"Extracts the type from a _GenericAlias *Args*: tp: type *Returns*: tp: type of generic type \"\"\" if isinstance ( given_type , _GenericAlias ) and given_type is not Generic : return given_type . __args__ [ 0 ] # assume we only have generic types with a single argument return given_type def check_for_defaults ( self , val ) : \"\"\"Checks for default values *Args*: default: default value default_factory: default factory *Returns*: default_val: value of default found_default: boolean if default found \"\"\" found_default = False default_val = None if type ( val . type ). __name__ == 'ChoiceArg' : default_val = self . _check_choice_type ( val . type , val . type . default ) found_default = True elif type ( val . default ). __name__ != '_MISSING_TYPE' : default_val = val . default found_default = True elif type ( val . default_factory ). __name__ != '_MISSING_TYPE' : default_val = val . default_factory () found_default = True return default_val , found_default @staticmethod def _check_choice_type ( choice_set , val ) : \"\"\"Checks the type and set of a ChoiceArg value *Args*: choice_set: ChoiceArg instance val: value to set val_name: name of the parameter *Returns*: val: value to set \"\"\" if val not in choice_set . choice_set : raise ValueError ( f '{val} is not within the set of defined choices {choice_set.choice_set}' ) return val","title":"ConfigArgBuilder"},{"location":"reference/spock/builder/#methods","text":"","title":"Methods"},{"location":"reference/spock/builder/#check_for_defaults","text":"def check_for_defaults ( self , val ) Checks for default values Args : default : default value default_factory : default factory Returns : default_val : value of default found_default : boolean if default found View Source def check_for_defaults ( self , val ): \"\"\"Checks for default values *Args*: default: default value default_factory: default factory *Returns*: default_val: value of default found_default: boolean if default found \"\"\" found_default = False default_val = None if type ( val . type ). __name__ == 'ChoiceArg' : default_val = self . _check_choice_type ( val . type , val . type . default ) found_default = True elif type ( val . default ). __name__ != '_MISSING_TYPE' : default_val = val . default found_default = True elif type ( val . default_factory ). __name__ != '_MISSING_TYPE' : default_val = val . default_factory () found_default = True return default_val , found_default","title":"check_for_defaults"},{"location":"reference/spock/builder/#generate","text":"def generate ( self ) Generate method that returns the actual argument namespace Returns : argument namespace consisting of all config classes View Source def generate ( self ): \"\"\"Generate method that returns the actual argument namespace *Returns*: argument namespace consisting of all config classes \"\"\" return self . _arg_namespace","title":"generate"},{"location":"reference/spock/builder/#print_usage_and_exit","text":"def print_usage_and_exit ( self , msg = None , sys_exit = True ) Prints the help message and exits Args : msg : message to print pre exit Returns : None View Source def print_usage_and_exit ( self , msg= None , sys_exit= True ): \"\"\"Prints the help message and exits *Args*: msg: message to print pre exit *Returns*: None \"\"\" print ( ' USAGE:' ) print ( f' { sys . argv [ 0 ]} - c [ -- config ] config1 [ config2 , config3 , ... ] ' ) print ( ' CONFIG:' ) for data_class in self . _data_classes : print ( ' ' + data_class . __name__ + ' : ' ) dc_vars = vars ( data_class ) for key , val in dc_vars . get ( ' __dataclass_fields__' ) . items (): if type ( val . type ) . __name__ = = ' ChoiceArg' : type_name = type ( val . type ) . __name__ # Magic again -- check for type == type allows for delineation between basic types and list/tuples elif type ( val . type ) == type : type_name = val . type . __name__ else : type_name = val . type . __origin__ . __name__ type_name += ' [ ' + self . _extract_base_type ( val . type ) . __name__ + ' ] ' print ( f' { key }: { type_name } ' ) if msg is not None : print ( msg ) if sys_exit : sys . exit ( 1 )","title":"print_usage_and_exit"},{"location":"reference/spock/builder/#save","text":"def save ( self , user_specified_path = None , extra_info = True , file_extension = '.yaml' ) Saves the current config setup to file with a UUID Args : user_specified_path : if user provides a path it will be used as the path to write extra_info : additional info to write to saved config ( run date and git info ) file_extension : file type to write ( default : yaml ) Returns : self so that functions can be chained View Source def save ( self , user_specified_path = None , extra_info = True , file_extension = '.yaml' ): \"\"\"Saves the current config setup to file with a UUID *Args*: user_specified_path: if user provides a path it will be used as the path to write extra_info: additional info to write to saved config (run date and git info) file_extension: file type to write (default: yaml) *Returns*: self so that functions can be chained \"\"\" if user_specified_path is not None : save_path = Path ( user_specified_path ) elif self . _save_path is not None : save_path = Path ( self . _save_path ) else : raise ValueError ( 'Save did not receive a valid path from: (1) SavePathOptArg or (2) ' 'the user via user_specified_path' ) # Call the saver class and save function Saver (). save ( self . _arg_namespace , save_path , self . _create_save_path , extra_info , file_extension ) return self","title":"save"},{"location":"reference/spock/config/","text":"Module spock.config Creates the spock config decorator that wraps dataclasses View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Creates the spock config decorator that wraps dataclasses\"\"\" from spock._dataclasses import dataclass def spock_config ( * args , ** kwargs ): \"\"\"Wrapper to dataclass that forms the base of Spock configs *Args*: *args: **kwargs: *Returns*: frozen dataclass: frozen version of the dataclass \"\"\" kwargs [ 'frozen' ] = True return dataclass ( * args , ** kwargs ) Functions spock_config def spock_config ( * args , ** kwargs ) Wrapper to dataclass that forms the base of Spock configs Args : *args: **kwargs: Returns : frozen dataclass: frozen version of the dataclass View Source def spock_config ( * args , ** kwargs ): \"\"\"Wrapper to dataclass that forms the base of Spock configs *Args*: *args: **kwargs: *Returns*: frozen dataclass: frozen version of the dataclass \"\"\" kwargs [ 'frozen' ] = True return dataclass ( * args , ** kwargs )","title":"Config"},{"location":"reference/spock/config/#module-spockconfig","text":"Creates the spock config decorator that wraps dataclasses View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Creates the spock config decorator that wraps dataclasses\"\"\" from spock._dataclasses import dataclass def spock_config ( * args , ** kwargs ): \"\"\"Wrapper to dataclass that forms the base of Spock configs *Args*: *args: **kwargs: *Returns*: frozen dataclass: frozen version of the dataclass \"\"\" kwargs [ 'frozen' ] = True return dataclass ( * args , ** kwargs )","title":"Module spock.config"},{"location":"reference/spock/config/#functions","text":"","title":"Functions"},{"location":"reference/spock/config/#spock_config","text":"def spock_config ( * args , ** kwargs ) Wrapper to dataclass that forms the base of Spock configs Args : *args: **kwargs: Returns : frozen dataclass: frozen version of the dataclass View Source def spock_config ( * args , ** kwargs ): \"\"\"Wrapper to dataclass that forms the base of Spock configs *Args*: *args: **kwargs: *Returns*: frozen dataclass: frozen version of the dataclass \"\"\" kwargs [ 'frozen' ] = True return dataclass ( * args , ** kwargs )","title":"spock_config"},{"location":"reference/spock/handlers/","text":"Module spock.handlers I/O handlers for various file formats View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"I/O handlers for various file formats\"\"\" from abc import ABC from abc import abstractmethod import json import re import toml import yaml class Handler ( ABC ): \"\"\"Base class for file type loaders ABC for loaders \"\"\" @abstractmethod def load ( self , path ): \"\"\"Load function for file type *Args*: path: path to file *Returns*: \"\"\" raise NotImplementedError @abstractmethod def save ( self , out_dict , path ): \"\"\"Write function for file type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" raise NotImplementedError class YAMLHandler ( Handler ): \"\"\"YAML class for loading YAML config files Base YAML class \"\"\" # override default SafeLoader behavior to correctly # interpret 1e1 (as opposed to 1.e+1) as 10 # https://stackoverflow.com/questions/30458977/yaml-loads-5e-6-as-string-and-not-a-number/30462009#30462009 yaml . SafeLoader . add_implicit_resolver ( u 'tag:yaml.org,2002:float' , re . compile ( u '''^(?: [-+]?(?:[0-9][0-9_]*) \\\\ .[0-9_]*(?:[eE][-+]?[0-9]+)? |[-+]?(?:[0-9][0-9_]*)(?:[eE][-+]?[0-9]+) | \\\\ .[0-9_]+(?:[eE][-+][0-9]+)? |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+ \\\\ .[0-9_]* |[-+]? \\\\ .(?:inf|Inf|INF) | \\\\ .(?:nan|NaN|NAN))$''' , re . X ), list ( u '-+0123456789.' ) ) def load ( self , path ): \"\"\"YAML load function *Args*: path: path to YAML file *Returns*: base_payload: dictionary of read file \"\"\" file_contents = open ( path , 'r' ) . read () file_contents = re . sub ( r '--([a-zA-Z0-9_]*)' , r '\\g<1>: True' , file_contents ) base_payload = yaml . safe_load ( file_contents ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for YAML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" yaml . dump ( out_dict , path , default_flow_style = False ) class TOMLHandler ( Handler ): \"\"\"TOML class for loading TOML config files Base TOML class \"\"\" def load ( self , path ): \"\"\"TOML load function *Args*: path: path to TOML file Returns: base_payload: dictionary of read file \"\"\" base_payload = toml . load ( path ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for TOML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" toml . dump ( out_dict , path ) class JSONHandler ( Handler ): \"\"\"JSON class for loading JSON config files Base JSON class \"\"\" def load ( self , path ): \"\"\"JSON load function *Args*: path: path to JSON file Returns: base_payload: dictionary of read file \"\"\" with open ( path ) as json_fid : base_payload = json . load ( json_fid ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for JSON type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" with open ( path . name , 'w' ) as json_fid : json . dump ( out_dict , json_fid , indent = 4 , separators = ( ',' , ': ' )) Classes Handler class Handler ( / , * args , ** kwargs ) Base class for file type loaders ABC for loaders View Source class Handler ( ABC ) : \"\"\"Base class for file type loaders ABC for loaders \"\"\" @abstractmethod def load ( self , path ) : \"\"\"Load function for file type *Args*: path: path to file *Returns*: \"\"\" raise NotImplementedError @abstractmethod def save ( self , out_dict , path ) : \"\"\"Write function for file type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" raise NotImplementedError Ancestors (in MRO) abc.ABC Descendants spock.handlers.YAMLHandler spock.handlers.TOMLHandler spock.handlers.JSONHandler Methods load def load ( self , path ) Load function for file type Args : path : path to file Returns : View Source @abstractmethod def load ( self , path ) : \"\"\"Load function for file type *Args*: path: path to file *Returns*: \"\"\" raise NotImplementedError save def save ( self , out_dict , path ) Write function for file type Args : out_dict : payload to write path : path to write out Returns : View Source @abstractmethod def save ( self , out_dict , path ) : \"\"\"Write function for file type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" raise NotImplementedError JSONHandler class JSONHandler ( / , * args , ** kwargs ) JSON class for loading JSON config files Base JSON class View Source class JSONHandler ( Handler ): \"\"\"JSON class for loading JSON config files Base JSON class \"\"\" def load ( self , path ): \"\"\"JSON load function *Args*: path: path to JSON file Returns: base_payload: dictionary of read file \"\"\" with open ( path ) as json_fid: base_payload = json . load ( json_fid ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for JSON type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" with open ( path . name , 'w' ) as json_fid: json . dump ( out_dict , json_fid , indent = 4 , separators =( ',' , ': ' )) Ancestors (in MRO) spock.handlers.Handler abc.ABC Methods load def load ( self , path ) JSON load function Args : path : path to JSON file Returns: base_payload : dictionary of read file View Source def load ( self , path ): \"\"\"JSON load function *Args*: path: path to JSON file Returns: base_payload: dictionary of read file \"\"\" with open ( path ) as json_fid : base_payload = json . load ( json_fid ) return base_payload save def save ( self , out_dict , path ) Write function for JSON type Args : out_dict : payload to write path : path to write out Returns : View Source def save ( self , out_dict , path ): \"\"\"Write function for JSON type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" with open ( path . name , 'w' ) as json_fid : json . dump ( out_dict , json_fid , indent = 4 , separators = ( ',' , ': ' )) TOMLHandler class TOMLHandler ( / , * args , ** kwargs ) TOML class for loading TOML config files Base TOML class View Source class TOMLHandler ( Handler ): \"\"\"TOML class for loading TOML config files Base TOML class \"\"\" def load ( self , path ): \"\"\"TOML load function *Args*: path: path to TOML file Returns: base_payload: dictionary of read file \"\"\" base_payload = toml . load ( path ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for TOML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" toml . dump ( out_dict , path ) Ancestors (in MRO) spock.handlers.Handler abc.ABC Methods load def load ( self , path ) TOML load function Args : path : path to TOML file Returns: base_payload : dictionary of read file View Source def load ( self , path ): \"\"\"TOML load function *Args*: path: path to TOML file Returns: base_payload: dictionary of read file \"\"\" base_payload = toml . load ( path ) return base_payload save def save ( self , out_dict , path ) Write function for TOML type Args : out_dict : payload to write path : path to write out Returns : View Source def save ( self , out_dict , path ): \"\"\"Write function for TOML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" toml . dump ( out_dict , path ) YAMLHandler class YAMLHandler ( / , * args , ** kwargs ) YAML class for loading YAML config files Base YAML class View Source class YAMLHandler ( Handler ) : \"\"\"YAML class for loading YAML config files Base YAML class \"\"\" # override default SafeLoader behavior to correctly # interpret 1e1 ( as opposed to 1.e+1 ) as 10 # https : // stackoverflow . com / questions / 30458977 / yaml - loads - 5e-6 - as - string - and - not - a - number / 30462009 #30462009 yaml . SafeLoader . add_implicit_resolver ( u 'tag:yaml.org,2002:float' , re . compile ( u '''^(?: [-+]?(?:[0-9][0-9_]*)\\\\.[0-9_]*(?:[eE][-+]?[0-9]+)? |[-+]?(?:[0-9][0-9_]*)(?:[eE][-+]?[0-9]+) |\\\\.[0-9_]+(?:[eE][-+][0-9]+)? |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]* |[-+]?\\\\.(?:inf|Inf|INF) |\\\\.(?:nan|NaN|NAN))$''' , re . X ), list ( u '-+0123456789.' ) ) def load ( self , path ) : \"\"\"YAML load function *Args*: path: path to YAML file *Returns*: base_payload: dictionary of read file \"\"\" file_contents = open ( path , 'r' ). read () file_contents = re . sub ( r '--([a-zA-Z0-9_]*)' , r '\\g<1>: True' , file_contents ) base_payload = yaml . safe_load ( file_contents ) return base_payload def save ( self , out_dict , path ) : \"\"\"Write function for YAML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" yaml . dump ( out_dict , path , default_flow_style = False ) Ancestors (in MRO) spock.handlers.Handler abc.ABC Methods load def load ( self , path ) YAML load function Args : path : path to YAML file Returns : base_payload : dictionary of read file View Source def load ( self , path ): \"\"\"YAML load function *Args*: path: path to YAML file *Returns*: base_payload: dictionary of read file \"\"\" file_contents = open ( path , 'r' ). read () file_contents = re . sub ( r '--([a-zA-Z0-9_]*)' , r '\\g<1>: True' , file_contents ) base_payload = yaml . safe_load ( file_contents ) return base_payload save def save ( self , out_dict , path ) Write function for YAML type Args : out_dict : payload to write path : path to write out Returns : View Source def save ( self , out_dict , path ): \"\"\"Write function for YAML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" yaml . dump ( out_dict , path , default_flow_style = False )","title":"Handlers"},{"location":"reference/spock/handlers/#module-spockhandlers","text":"I/O handlers for various file formats View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"I/O handlers for various file formats\"\"\" from abc import ABC from abc import abstractmethod import json import re import toml import yaml class Handler ( ABC ): \"\"\"Base class for file type loaders ABC for loaders \"\"\" @abstractmethod def load ( self , path ): \"\"\"Load function for file type *Args*: path: path to file *Returns*: \"\"\" raise NotImplementedError @abstractmethod def save ( self , out_dict , path ): \"\"\"Write function for file type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" raise NotImplementedError class YAMLHandler ( Handler ): \"\"\"YAML class for loading YAML config files Base YAML class \"\"\" # override default SafeLoader behavior to correctly # interpret 1e1 (as opposed to 1.e+1) as 10 # https://stackoverflow.com/questions/30458977/yaml-loads-5e-6-as-string-and-not-a-number/30462009#30462009 yaml . SafeLoader . add_implicit_resolver ( u 'tag:yaml.org,2002:float' , re . compile ( u '''^(?: [-+]?(?:[0-9][0-9_]*) \\\\ .[0-9_]*(?:[eE][-+]?[0-9]+)? |[-+]?(?:[0-9][0-9_]*)(?:[eE][-+]?[0-9]+) | \\\\ .[0-9_]+(?:[eE][-+][0-9]+)? |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+ \\\\ .[0-9_]* |[-+]? \\\\ .(?:inf|Inf|INF) | \\\\ .(?:nan|NaN|NAN))$''' , re . X ), list ( u '-+0123456789.' ) ) def load ( self , path ): \"\"\"YAML load function *Args*: path: path to YAML file *Returns*: base_payload: dictionary of read file \"\"\" file_contents = open ( path , 'r' ) . read () file_contents = re . sub ( r '--([a-zA-Z0-9_]*)' , r '\\g<1>: True' , file_contents ) base_payload = yaml . safe_load ( file_contents ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for YAML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" yaml . dump ( out_dict , path , default_flow_style = False ) class TOMLHandler ( Handler ): \"\"\"TOML class for loading TOML config files Base TOML class \"\"\" def load ( self , path ): \"\"\"TOML load function *Args*: path: path to TOML file Returns: base_payload: dictionary of read file \"\"\" base_payload = toml . load ( path ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for TOML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" toml . dump ( out_dict , path ) class JSONHandler ( Handler ): \"\"\"JSON class for loading JSON config files Base JSON class \"\"\" def load ( self , path ): \"\"\"JSON load function *Args*: path: path to JSON file Returns: base_payload: dictionary of read file \"\"\" with open ( path ) as json_fid : base_payload = json . load ( json_fid ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for JSON type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" with open ( path . name , 'w' ) as json_fid : json . dump ( out_dict , json_fid , indent = 4 , separators = ( ',' , ': ' ))","title":"Module spock.handlers"},{"location":"reference/spock/handlers/#classes","text":"","title":"Classes"},{"location":"reference/spock/handlers/#handler","text":"class Handler ( / , * args , ** kwargs ) Base class for file type loaders ABC for loaders View Source class Handler ( ABC ) : \"\"\"Base class for file type loaders ABC for loaders \"\"\" @abstractmethod def load ( self , path ) : \"\"\"Load function for file type *Args*: path: path to file *Returns*: \"\"\" raise NotImplementedError @abstractmethod def save ( self , out_dict , path ) : \"\"\"Write function for file type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" raise NotImplementedError","title":"Handler"},{"location":"reference/spock/handlers/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/spock/handlers/#descendants","text":"spock.handlers.YAMLHandler spock.handlers.TOMLHandler spock.handlers.JSONHandler","title":"Descendants"},{"location":"reference/spock/handlers/#methods","text":"","title":"Methods"},{"location":"reference/spock/handlers/#load","text":"def load ( self , path ) Load function for file type Args : path : path to file Returns : View Source @abstractmethod def load ( self , path ) : \"\"\"Load function for file type *Args*: path: path to file *Returns*: \"\"\" raise NotImplementedError","title":"load"},{"location":"reference/spock/handlers/#save","text":"def save ( self , out_dict , path ) Write function for file type Args : out_dict : payload to write path : path to write out Returns : View Source @abstractmethod def save ( self , out_dict , path ) : \"\"\"Write function for file type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" raise NotImplementedError","title":"save"},{"location":"reference/spock/handlers/#jsonhandler","text":"class JSONHandler ( / , * args , ** kwargs ) JSON class for loading JSON config files Base JSON class View Source class JSONHandler ( Handler ): \"\"\"JSON class for loading JSON config files Base JSON class \"\"\" def load ( self , path ): \"\"\"JSON load function *Args*: path: path to JSON file Returns: base_payload: dictionary of read file \"\"\" with open ( path ) as json_fid: base_payload = json . load ( json_fid ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for JSON type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" with open ( path . name , 'w' ) as json_fid: json . dump ( out_dict , json_fid , indent = 4 , separators =( ',' , ': ' ))","title":"JSONHandler"},{"location":"reference/spock/handlers/#ancestors-in-mro_1","text":"spock.handlers.Handler abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/spock/handlers/#methods_1","text":"","title":"Methods"},{"location":"reference/spock/handlers/#load_1","text":"def load ( self , path ) JSON load function Args : path : path to JSON file Returns: base_payload : dictionary of read file View Source def load ( self , path ): \"\"\"JSON load function *Args*: path: path to JSON file Returns: base_payload: dictionary of read file \"\"\" with open ( path ) as json_fid : base_payload = json . load ( json_fid ) return base_payload","title":"load"},{"location":"reference/spock/handlers/#save_1","text":"def save ( self , out_dict , path ) Write function for JSON type Args : out_dict : payload to write path : path to write out Returns : View Source def save ( self , out_dict , path ): \"\"\"Write function for JSON type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" with open ( path . name , 'w' ) as json_fid : json . dump ( out_dict , json_fid , indent = 4 , separators = ( ',' , ': ' ))","title":"save"},{"location":"reference/spock/handlers/#tomlhandler","text":"class TOMLHandler ( / , * args , ** kwargs ) TOML class for loading TOML config files Base TOML class View Source class TOMLHandler ( Handler ): \"\"\"TOML class for loading TOML config files Base TOML class \"\"\" def load ( self , path ): \"\"\"TOML load function *Args*: path: path to TOML file Returns: base_payload: dictionary of read file \"\"\" base_payload = toml . load ( path ) return base_payload def save ( self , out_dict , path ): \"\"\"Write function for TOML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" toml . dump ( out_dict , path )","title":"TOMLHandler"},{"location":"reference/spock/handlers/#ancestors-in-mro_2","text":"spock.handlers.Handler abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/spock/handlers/#methods_2","text":"","title":"Methods"},{"location":"reference/spock/handlers/#load_2","text":"def load ( self , path ) TOML load function Args : path : path to TOML file Returns: base_payload : dictionary of read file View Source def load ( self , path ): \"\"\"TOML load function *Args*: path: path to TOML file Returns: base_payload: dictionary of read file \"\"\" base_payload = toml . load ( path ) return base_payload","title":"load"},{"location":"reference/spock/handlers/#save_2","text":"def save ( self , out_dict , path ) Write function for TOML type Args : out_dict : payload to write path : path to write out Returns : View Source def save ( self , out_dict , path ): \"\"\"Write function for TOML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" toml . dump ( out_dict , path )","title":"save"},{"location":"reference/spock/handlers/#yamlhandler","text":"class YAMLHandler ( / , * args , ** kwargs ) YAML class for loading YAML config files Base YAML class View Source class YAMLHandler ( Handler ) : \"\"\"YAML class for loading YAML config files Base YAML class \"\"\" # override default SafeLoader behavior to correctly # interpret 1e1 ( as opposed to 1.e+1 ) as 10 # https : // stackoverflow . com / questions / 30458977 / yaml - loads - 5e-6 - as - string - and - not - a - number / 30462009 #30462009 yaml . SafeLoader . add_implicit_resolver ( u 'tag:yaml.org,2002:float' , re . compile ( u '''^(?: [-+]?(?:[0-9][0-9_]*)\\\\.[0-9_]*(?:[eE][-+]?[0-9]+)? |[-+]?(?:[0-9][0-9_]*)(?:[eE][-+]?[0-9]+) |\\\\.[0-9_]+(?:[eE][-+][0-9]+)? |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]* |[-+]?\\\\.(?:inf|Inf|INF) |\\\\.(?:nan|NaN|NAN))$''' , re . X ), list ( u '-+0123456789.' ) ) def load ( self , path ) : \"\"\"YAML load function *Args*: path: path to YAML file *Returns*: base_payload: dictionary of read file \"\"\" file_contents = open ( path , 'r' ). read () file_contents = re . sub ( r '--([a-zA-Z0-9_]*)' , r '\\g<1>: True' , file_contents ) base_payload = yaml . safe_load ( file_contents ) return base_payload def save ( self , out_dict , path ) : \"\"\"Write function for YAML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" yaml . dump ( out_dict , path , default_flow_style = False )","title":"YAMLHandler"},{"location":"reference/spock/handlers/#ancestors-in-mro_3","text":"spock.handlers.Handler abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/spock/handlers/#methods_3","text":"","title":"Methods"},{"location":"reference/spock/handlers/#load_3","text":"def load ( self , path ) YAML load function Args : path : path to YAML file Returns : base_payload : dictionary of read file View Source def load ( self , path ): \"\"\"YAML load function *Args*: path: path to YAML file *Returns*: base_payload: dictionary of read file \"\"\" file_contents = open ( path , 'r' ). read () file_contents = re . sub ( r '--([a-zA-Z0-9_]*)' , r '\\g<1>: True' , file_contents ) base_payload = yaml . safe_load ( file_contents ) return base_payload","title":"load"},{"location":"reference/spock/handlers/#save_3","text":"def save ( self , out_dict , path ) Write function for YAML type Args : out_dict : payload to write path : path to write out Returns : View Source def save ( self , out_dict , path ): \"\"\"Write function for YAML type *Args*: out_dict: payload to write path: path to write out *Returns*: \"\"\" yaml . dump ( out_dict , path , default_flow_style = False )","title":"save"},{"location":"reference/spock/payload/","text":"Module spock.payload Handles payloads from markup files View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Handles payloads from markup files\"\"\" from itertools import chain import os from pathlib import Path from spock.handlers import JSONHandler from spock.handlers import TOMLHandler from spock.handlers import YAMLHandler class Payload : \"\"\"Handles building the payload for config file(s) This class builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Attributes*: _loaders: maps of each file extension to the loader class \"\"\" def __init__ ( self ): self . _loaders = { '.yaml' : YAMLHandler (), '.toml' : TOMLHandler (), '.json' : JSONHandler ()} def __call__ ( self , * args , ** kwargs ): \"\"\"Call to allow self chaining *Args*: *args: **kwargs: *Returns*: Payload: instance of self \"\"\" return Payload () def payload ( self , data_classes , path ): \"\"\"Builds the payload from config files Main function call that builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Args*: data_classes: list of dataclasses that define the necessary parameters path: path to config file(s) *Returns*: payload: dictionary of all mapped parameters \"\"\" # Match to loader based on file-extension config_extension = Path ( path ) . suffix . lower () supported_extensions = list ( self . _loaders . keys ()) if config_extension not in supported_extensions : raise TypeError ( f 'File extension {config_extension} not supported \\n ' f 'Must be from {supported_extensions}' ) # Load from file base_payload = self . _loaders . get ( config_extension ) . load ( path ) payload = {} if 'config' in base_payload : payload = self . _handle_includes ( base_payload , config_extension , data_classes , path , payload ) payload = self . _update_payload ( base_payload , data_classes , payload ) return payload @staticmethod def _update_payload ( base_payload , data_classes , payload ): \"\"\"Updates the payload Checks the parameters defined in the config files against the provided dataclasses and if passable adds them to the payload *Args*: base_payload: current payload data_classes: dataclass to roll into payload: total payload *Returns*: payload: updated payload \"\"\" # Get basic args dc_fields = { dc . __name__ : list ( vars ( dc ) . get ( '__dataclass_fields__' ) . keys ()) for dc in data_classes } # Get the choice args and insert them # dc_fields = self._handle_choices(dc_fields, data_classes) for keys , values in base_payload . items (): # check if the keys, value pair is expected by a dataclass if keys != 'config' : # Dict infers that we are overriding a global setting in a specific config if isinstance ( values , dict ): # we're in a namespace # Check for incorrect specific override of global def if keys not in dc_fields : raise TypeError ( f 'Referring to a class space {keys} that is undefined' ) for i_keys in values . keys (): if i_keys not in dc_fields [ keys ]: raise ValueError ( f 'Provided an unknown argument named {keys}.{i_keys}' ) else : # Chain all the values from multiple spock classes into one list if keys not in list ( chain ( * dc_fields . values ())): raise ValueError ( f 'Provided an unknown argument named {keys}' ) if keys in payload and isinstance ( values , dict ): payload [ keys ] . update ( values ) else : payload [ keys ] = values return payload def _handle_includes ( self , base_payload , config_extension , data_classes , path , payload ): #pylint: disable=too-many-arguments \"\"\"Handles config composition For all of the config tags in the config file this function will recursively call the payload function with the composition path to get the additional payload(s) from the composed file(s) *Args*: base_payload: base payload that has a config kwarg config_extension: file type data_classes: defined dataclasses path: path to base file payload: payload pulled from composed files Returns: payload: payload update from composed files \"\"\" included_params = {} for inc_path in base_payload [ 'config' ]: if not os . path . exists ( inc_path ): # maybe it's relative? abs_inc_path = os . path . join ( os . path . dirname ( path ), inc_path ) else : abs_inc_path = inc_path if not os . path . exists ( abs_inc_path ): raise RuntimeError ( f 'Could not find included {config_extension} file {inc_path}!' ) included_params . update ( self . payload ( data_classes , abs_inc_path )) payload . update ( included_params ) return payload Classes Payload class Payload ( ) Handles building the payload for config file(s) This class builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls Attributes : _loaders : maps of each file extension to the loader class View Source class Payload : \"\"\"Handles building the payload for config file(s) This class builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Attributes*: _loaders: maps of each file extension to the loader class \"\"\" def __init__ ( self ) : self . _loaders = { '.yaml' : YAMLHandler (), '.toml' : TOMLHandler (), '.json' : JSONHandler () } def __call__ ( self , * args , ** kwargs ) : \"\"\"Call to allow self chaining *Args*: *args: **kwargs: *Returns*: Payload: instance of self \"\"\" return Payload () def payload ( self , data_classes , path ) : \"\"\"Builds the payload from config files Main function call that builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Args*: data_classes: list of dataclasses that define the necessary parameters path: path to config file(s) *Returns*: payload: dictionary of all mapped parameters \"\"\" # Match to loader based on file - extension config_extension = Path ( path ). suffix . lower () supported_extensions = list ( self . _loaders . keys ()) if config_extension not in supported_extensions : raise TypeError ( f 'File extension {config_extension} not supported\\n' f 'Must be from {supported_extensions}' ) # Load from file base_payload = self . _loaders . get ( config_extension ). load ( path ) payload = {} if 'config' in base_payload : payload = self . _handle_includes ( base_payload , config_extension , data_classes , path , payload ) payload = self . _update_payload ( base_payload , data_classes , payload ) return payload @staticmethod def _update_payload ( base_payload , data_classes , payload ) : \"\"\"Updates the payload Checks the parameters defined in the config files against the provided dataclasses and if passable adds them to the payload *Args*: base_payload: current payload data_classes: dataclass to roll into payload: total payload *Returns*: payload: updated payload \"\"\" # Get basic args dc_fields = { dc . __name__ : list ( vars ( dc ). get ( '__dataclass_fields__' ). keys ()) for dc in data_classes } # Get the choice args and insert them # dc_fields = self . _handle_choices ( dc_fields , data_classes ) for keys , values in base_payload . items () : # check if the keys , value pair is expected by a dataclass if keys != 'config' : # Dict infers that we are overriding a global setting in a specific config if isinstance ( values , dict ) : # we 're in a namespace # Check for incorrect specific override of global def if keys not in dc_fields: raise TypeError(f' Referring to a class space { keys } that is undefined ') for i_keys in values.keys(): if i_keys not in dc_fields[keys]: raise ValueError(f' Provided an unknown argument named { keys } . { i_keys } ') else: # Chain all the values from multiple spock classes into one list if keys not in list(chain(*dc_fields.values())): raise ValueError(f' Provided an unknown argument named { keys } ') if keys in payload and isinstance(values, dict): payload[keys].update(values) else: payload[keys] = values return payload def _handle_includes(self, base_payload, config_extension, data_classes, path, payload): #pylint: disable=too-many-arguments \"\"\"Handles config composition For all of the config tags in the config file this function will recursively call the payload function with the composition path to get the additional payload(s) from the composed file(s) *Args*: base_payload: base payload that has a config kwarg config_extension: file type data_classes: defined dataclasses path: path to base file payload: payload pulled from composed files Returns: payload: payload update from composed files \"\"\" included_params = {} for inc_path in base_payload[' config ']: if not os.path.exists(inc_path): # maybe it' s relative ? abs_inc_path = os . path . join ( os . path . dirname ( path ), inc_path ) else : abs_inc_path = inc_path if not os . path . exists ( abs_inc_path ) : raise RuntimeError ( f 'Could not find included {config_extension} file {inc_path}!' ) included_params . update ( self . payload ( data_classes , abs_inc_path )) payload . update ( included_params ) return payload Methods payload def payload ( self , data_classes , path ) Builds the payload from config files Main function call that builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls Args : data_classes : list of dataclasses that define the necessary parameters path : path to config file ( s ) Returns : payload : dictionary of all mapped parameters View Source def payload ( self , data_classes , path ): \"\"\"Builds the payload from config files Main function call that builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Args*: data_classes: list of dataclasses that define the necessary parameters path: path to config file(s) *Returns*: payload: dictionary of all mapped parameters \"\"\" # Match to loader based on file - extension config_extension = Path ( path ). suffix . lower () supported_extensions = list ( self . _loaders . keys ()) if config_extension not in supported_extensions : raise TypeError ( f 'File extension {config_extension} not supported\\n' f 'Must be from {supported_extensions}' ) # Load from file base_payload = self . _loaders . get ( config_extension ). load ( path ) payload = {} if 'config' in base_payload : payload = self . _handle_includes ( base_payload , config_extension , data_classes , path , payload ) payload = self . _update_payload ( base_payload , data_classes , payload ) return payload","title":"Payload"},{"location":"reference/spock/payload/#module-spockpayload","text":"Handles payloads from markup files View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Handles payloads from markup files\"\"\" from itertools import chain import os from pathlib import Path from spock.handlers import JSONHandler from spock.handlers import TOMLHandler from spock.handlers import YAMLHandler class Payload : \"\"\"Handles building the payload for config file(s) This class builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Attributes*: _loaders: maps of each file extension to the loader class \"\"\" def __init__ ( self ): self . _loaders = { '.yaml' : YAMLHandler (), '.toml' : TOMLHandler (), '.json' : JSONHandler ()} def __call__ ( self , * args , ** kwargs ): \"\"\"Call to allow self chaining *Args*: *args: **kwargs: *Returns*: Payload: instance of self \"\"\" return Payload () def payload ( self , data_classes , path ): \"\"\"Builds the payload from config files Main function call that builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Args*: data_classes: list of dataclasses that define the necessary parameters path: path to config file(s) *Returns*: payload: dictionary of all mapped parameters \"\"\" # Match to loader based on file-extension config_extension = Path ( path ) . suffix . lower () supported_extensions = list ( self . _loaders . keys ()) if config_extension not in supported_extensions : raise TypeError ( f 'File extension {config_extension} not supported \\n ' f 'Must be from {supported_extensions}' ) # Load from file base_payload = self . _loaders . get ( config_extension ) . load ( path ) payload = {} if 'config' in base_payload : payload = self . _handle_includes ( base_payload , config_extension , data_classes , path , payload ) payload = self . _update_payload ( base_payload , data_classes , payload ) return payload @staticmethod def _update_payload ( base_payload , data_classes , payload ): \"\"\"Updates the payload Checks the parameters defined in the config files against the provided dataclasses and if passable adds them to the payload *Args*: base_payload: current payload data_classes: dataclass to roll into payload: total payload *Returns*: payload: updated payload \"\"\" # Get basic args dc_fields = { dc . __name__ : list ( vars ( dc ) . get ( '__dataclass_fields__' ) . keys ()) for dc in data_classes } # Get the choice args and insert them # dc_fields = self._handle_choices(dc_fields, data_classes) for keys , values in base_payload . items (): # check if the keys, value pair is expected by a dataclass if keys != 'config' : # Dict infers that we are overriding a global setting in a specific config if isinstance ( values , dict ): # we're in a namespace # Check for incorrect specific override of global def if keys not in dc_fields : raise TypeError ( f 'Referring to a class space {keys} that is undefined' ) for i_keys in values . keys (): if i_keys not in dc_fields [ keys ]: raise ValueError ( f 'Provided an unknown argument named {keys}.{i_keys}' ) else : # Chain all the values from multiple spock classes into one list if keys not in list ( chain ( * dc_fields . values ())): raise ValueError ( f 'Provided an unknown argument named {keys}' ) if keys in payload and isinstance ( values , dict ): payload [ keys ] . update ( values ) else : payload [ keys ] = values return payload def _handle_includes ( self , base_payload , config_extension , data_classes , path , payload ): #pylint: disable=too-many-arguments \"\"\"Handles config composition For all of the config tags in the config file this function will recursively call the payload function with the composition path to get the additional payload(s) from the composed file(s) *Args*: base_payload: base payload that has a config kwarg config_extension: file type data_classes: defined dataclasses path: path to base file payload: payload pulled from composed files Returns: payload: payload update from composed files \"\"\" included_params = {} for inc_path in base_payload [ 'config' ]: if not os . path . exists ( inc_path ): # maybe it's relative? abs_inc_path = os . path . join ( os . path . dirname ( path ), inc_path ) else : abs_inc_path = inc_path if not os . path . exists ( abs_inc_path ): raise RuntimeError ( f 'Could not find included {config_extension} file {inc_path}!' ) included_params . update ( self . payload ( data_classes , abs_inc_path )) payload . update ( included_params ) return payload","title":"Module spock.payload"},{"location":"reference/spock/payload/#classes","text":"","title":"Classes"},{"location":"reference/spock/payload/#payload","text":"class Payload ( ) Handles building the payload for config file(s) This class builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls Attributes : _loaders : maps of each file extension to the loader class View Source class Payload : \"\"\"Handles building the payload for config file(s) This class builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Attributes*: _loaders: maps of each file extension to the loader class \"\"\" def __init__ ( self ) : self . _loaders = { '.yaml' : YAMLHandler (), '.toml' : TOMLHandler (), '.json' : JSONHandler () } def __call__ ( self , * args , ** kwargs ) : \"\"\"Call to allow self chaining *Args*: *args: **kwargs: *Returns*: Payload: instance of self \"\"\" return Payload () def payload ( self , data_classes , path ) : \"\"\"Builds the payload from config files Main function call that builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Args*: data_classes: list of dataclasses that define the necessary parameters path: path to config file(s) *Returns*: payload: dictionary of all mapped parameters \"\"\" # Match to loader based on file - extension config_extension = Path ( path ). suffix . lower () supported_extensions = list ( self . _loaders . keys ()) if config_extension not in supported_extensions : raise TypeError ( f 'File extension {config_extension} not supported\\n' f 'Must be from {supported_extensions}' ) # Load from file base_payload = self . _loaders . get ( config_extension ). load ( path ) payload = {} if 'config' in base_payload : payload = self . _handle_includes ( base_payload , config_extension , data_classes , path , payload ) payload = self . _update_payload ( base_payload , data_classes , payload ) return payload @staticmethod def _update_payload ( base_payload , data_classes , payload ) : \"\"\"Updates the payload Checks the parameters defined in the config files against the provided dataclasses and if passable adds them to the payload *Args*: base_payload: current payload data_classes: dataclass to roll into payload: total payload *Returns*: payload: updated payload \"\"\" # Get basic args dc_fields = { dc . __name__ : list ( vars ( dc ). get ( '__dataclass_fields__' ). keys ()) for dc in data_classes } # Get the choice args and insert them # dc_fields = self . _handle_choices ( dc_fields , data_classes ) for keys , values in base_payload . items () : # check if the keys , value pair is expected by a dataclass if keys != 'config' : # Dict infers that we are overriding a global setting in a specific config if isinstance ( values , dict ) : # we 're in a namespace # Check for incorrect specific override of global def if keys not in dc_fields: raise TypeError(f' Referring to a class space { keys } that is undefined ') for i_keys in values.keys(): if i_keys not in dc_fields[keys]: raise ValueError(f' Provided an unknown argument named { keys } . { i_keys } ') else: # Chain all the values from multiple spock classes into one list if keys not in list(chain(*dc_fields.values())): raise ValueError(f' Provided an unknown argument named { keys } ') if keys in payload and isinstance(values, dict): payload[keys].update(values) else: payload[keys] = values return payload def _handle_includes(self, base_payload, config_extension, data_classes, path, payload): #pylint: disable=too-many-arguments \"\"\"Handles config composition For all of the config tags in the config file this function will recursively call the payload function with the composition path to get the additional payload(s) from the composed file(s) *Args*: base_payload: base payload that has a config kwarg config_extension: file type data_classes: defined dataclasses path: path to base file payload: payload pulled from composed files Returns: payload: payload update from composed files \"\"\" included_params = {} for inc_path in base_payload[' config ']: if not os.path.exists(inc_path): # maybe it' s relative ? abs_inc_path = os . path . join ( os . path . dirname ( path ), inc_path ) else : abs_inc_path = inc_path if not os . path . exists ( abs_inc_path ) : raise RuntimeError ( f 'Could not find included {config_extension} file {inc_path}!' ) included_params . update ( self . payload ( data_classes , abs_inc_path )) payload . update ( included_params ) return payload","title":"Payload"},{"location":"reference/spock/payload/#methods","text":"","title":"Methods"},{"location":"reference/spock/payload/#payload_1","text":"def payload ( self , data_classes , path ) Builds the payload from config files Main function call that builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls Args : data_classes : list of dataclasses that define the necessary parameters path : path to config file ( s ) Returns : payload : dictionary of all mapped parameters View Source def payload ( self , data_classes , path ): \"\"\"Builds the payload from config files Main function call that builds out the payload from config files of multiple types. It handles various file types and also composition of config files via a recursive calls *Args*: data_classes: list of dataclasses that define the necessary parameters path: path to config file(s) *Returns*: payload: dictionary of all mapped parameters \"\"\" # Match to loader based on file - extension config_extension = Path ( path ). suffix . lower () supported_extensions = list ( self . _loaders . keys ()) if config_extension not in supported_extensions : raise TypeError ( f 'File extension {config_extension} not supported\\n' f 'Must be from {supported_extensions}' ) # Load from file base_payload = self . _loaders . get ( config_extension ). load ( path ) payload = {} if 'config' in base_payload : payload = self . _handle_includes ( base_payload , config_extension , data_classes , path , payload ) payload = self . _update_payload ( base_payload , data_classes , payload ) return payload","title":"payload"},{"location":"reference/spock/saver/","text":"Module spock.saver Handles prepping and saving the Spock config View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Handles prepping and saving the Spock config\"\"\" import os from uuid import uuid1 from spock._dataclasses import asdict from spock.handlers import JSONHandler from spock.handlers import TOMLHandler from spock.handlers import YAMLHandler from spock.utils import add_info class Saver : \"\"\"Base class for saving configs Contains methods to build a correct output payload and then writes to file based on the file extension *Attributes*: _writers: maps file extension to the correct i/o handler \"\"\" def __init__ ( self ): self . _writers = { '.yaml' : YAMLHandler , '.toml' : TOMLHandler , '.json' : JSONHandler } def __call__ ( self , * args , ** kwargs ): return Saver () def save ( self , payload , path , create_save_path = False , extra_info = True , file_extension = '.yaml' ): #pylint: disable=too-many-arguments \"\"\"Writes Spock config to file Cleans and builds an output payload and then correctly writes it to file based on the specified file extension *Args*: payload: current config payload path: path to save create_save_path: boolean to create the path if non-existent extra_info: boolean to write extra info file_extension: what type of file to write *Returns*: None \"\"\" supported_extensions = list ( self . _writers . keys ()) if file_extension not in list ( self . _writers . keys ()): raise ValueError ( f 'Invalid fileout extension. Expected a fileout from {supported_extensions}' ) # Make the filename name = str ( uuid1 ()) + '.spck.cfg' + file_extension fid = path / name # Fix up values out_dict = self . _clean_up_values ( payload , extra_info , file_extension ) try : if not os . path . exists ( path ) and create_save_path : os . makedirs ( path ) with open ( fid , 'w' ) as file_out : self . _writers . get ( file_extension )() . save ( out_dict , file_out ) # yaml.dump(out_dict, file_out, default_flow_style=False) except OSError : print ( 'Not a valid file path to write to: {}' . format ( fid )) @staticmethod def _clean_up_values ( payload , extra_info , file_extension ): \"\"\"Clean up the config payload so it can be written to file *Args*: payload: dirty payload extra_info: boolean to add extra info file_extension: type of file to write *Returns*: clean_dict: cleaned output payload \"\"\" out_dict = {} for key , val in vars ( payload ) . items (): # Append comment tag to the base class and convert the spock class to a dict if file_extension == '.json' : out_dict . update ({ key : asdict ( val )}) else : out_dict . update ({( '# ' + key ): asdict ( val )}) # Convert values clean_dict = {} for key , val in out_dict . items (): clean_inner_dict = {} for inner_key , inner_val in val . items (): # Convert tuples to lists so they get written correctly if type ( inner_val ) == tuple : clean_inner_dict . update ({ inner_key : list ( inner_val )}) elif inner_val is not None : clean_inner_dict . update ({ inner_key : inner_val }) clean_dict . update ({ key : clean_inner_dict }) if extra_info : clean_dict = add_info ( clean_dict ) return clean_dict Classes Saver class Saver ( ) Base class for saving configs Contains methods to build a correct output payload and then writes to file based on the file extension Attributes : _writers : maps file extension to the correct i / o handler View Source class Saver : \"\"\"Base class for saving configs Contains methods to build a correct output payload and then writes to file based on the file extension *Attributes*: _writers: maps file extension to the correct i/o handler \"\"\" def __init__ ( self ) : self . _writers = { '.yaml' : YAMLHandler , '.toml' : TOMLHandler , '.json' : JSONHandler } def __call__ ( self , * args , ** kwargs ) : return Saver () def save ( self , payload , path , create_save_path = False , extra_info = True , file_extension = '.yaml' ) : #pylint : disable = too - many - arguments \"\"\"Writes Spock config to file Cleans and builds an output payload and then correctly writes it to file based on the specified file extension *Args*: payload: current config payload path: path to save create_save_path: boolean to create the path if non-existent extra_info: boolean to write extra info file_extension: what type of file to write *Returns*: None \"\"\" supported_extensions = list ( self . _writers . keys ()) if file_extension not in list ( self . _writers . keys ()) : raise ValueError ( f 'Invalid fileout extension. Expected a fileout from {supported_extensions}' ) # Make the filename name = str ( uuid1 ()) + '.spck.cfg' + file_extension fid = path / name # Fix up values out_dict = self . _clean_up_values ( payload , extra_info , file_extension ) try : if not os . path . exists ( path ) and create_save_path : os . makedirs ( path ) with open ( fid , 'w' ) as file_out : self . _writers . get ( file_extension )(). save ( out_dict , file_out ) # yaml . dump ( out_dict , file_out , default_flow_style = False ) except OSError : print ( 'Not a valid file path to write to: {}' . format ( fid )) @staticmethod def _clean_up_values ( payload , extra_info , file_extension ) : \"\"\"Clean up the config payload so it can be written to file *Args*: payload: dirty payload extra_info: boolean to add extra info file_extension: type of file to write *Returns*: clean_dict: cleaned output payload \"\"\" out_dict = {} for key , val in vars ( payload ). items () : # Append comment tag to the base class and convert the spock class to a dict if file_extension == '.json' : out_dict . update ( { key : asdict ( val ) } ) else : out_dict . update ( { ( '# ' + key ) : asdict ( val ) } ) # Convert values clean_dict = {} for key , val in out_dict . items () : clean_inner_dict = {} for inner_key , inner_val in val . items () : # Convert tuples to lists so they get written correctly if type ( inner_val ) == tuple : clean_inner_dict . update ( { inner_key : list ( inner_val ) } ) elif inner_val is not None : clean_inner_dict . update ( { inner_key : inner_val } ) clean_dict . update ( { key : clean_inner_dict } ) if extra_info : clean_dict = add_info ( clean_dict ) return clean_dict Methods save def save ( self , payload , path , create_save_path = False , extra_info = True , file_extension = '.yaml' ) Writes Spock config to file Cleans and builds an output payload and then correctly writes it to file based on the specified file extension Args : payload : current config payload path : path to save create_save_path : boolean to create the path if non - existent extra_info : boolean to write extra info file_extension : what type of file to write Returns : None View Source def save ( self , payload , path , create_save_path = False , extra_info = True , file_extension = '.yaml' ): # pylint : disable = too - many - arguments \"\"\"Writes Spock config to file Cleans and builds an output payload and then correctly writes it to file based on the specified file extension *Args*: payload: current config payload path: path to save create_save_path: boolean to create the path if non-existent extra_info: boolean to write extra info file_extension: what type of file to write *Returns*: None \"\"\" supported_extensions = list ( self . _writers . keys ()) if file_extension not in list ( self . _writers . keys ()): raise ValueError ( f 'Invalid fileout extension. Expected a fileout from {supported_extensions}' ) # Make the filename name = str ( uuid1 ()) + '.spck.cfg' + file_extension fid = path / name # Fix up values out_dict = self . _clean_up_values ( payload , extra_info , file_extension ) try : if not os . path . exists ( path ) and create_save_path : os . makedirs ( path ) with open ( fid , 'w' ) as file_out : self . _writers . get ( file_extension )(). save ( out_dict , file_out ) # yaml . dump ( out_dict , file_out , default_flow_style = False ) except OSError : print ( 'Not a valid file path to write to: {}' . format ( fid ))","title":"Saver"},{"location":"reference/spock/saver/#module-spocksaver","text":"Handles prepping and saving the Spock config View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Handles prepping and saving the Spock config\"\"\" import os from uuid import uuid1 from spock._dataclasses import asdict from spock.handlers import JSONHandler from spock.handlers import TOMLHandler from spock.handlers import YAMLHandler from spock.utils import add_info class Saver : \"\"\"Base class for saving configs Contains methods to build a correct output payload and then writes to file based on the file extension *Attributes*: _writers: maps file extension to the correct i/o handler \"\"\" def __init__ ( self ): self . _writers = { '.yaml' : YAMLHandler , '.toml' : TOMLHandler , '.json' : JSONHandler } def __call__ ( self , * args , ** kwargs ): return Saver () def save ( self , payload , path , create_save_path = False , extra_info = True , file_extension = '.yaml' ): #pylint: disable=too-many-arguments \"\"\"Writes Spock config to file Cleans and builds an output payload and then correctly writes it to file based on the specified file extension *Args*: payload: current config payload path: path to save create_save_path: boolean to create the path if non-existent extra_info: boolean to write extra info file_extension: what type of file to write *Returns*: None \"\"\" supported_extensions = list ( self . _writers . keys ()) if file_extension not in list ( self . _writers . keys ()): raise ValueError ( f 'Invalid fileout extension. Expected a fileout from {supported_extensions}' ) # Make the filename name = str ( uuid1 ()) + '.spck.cfg' + file_extension fid = path / name # Fix up values out_dict = self . _clean_up_values ( payload , extra_info , file_extension ) try : if not os . path . exists ( path ) and create_save_path : os . makedirs ( path ) with open ( fid , 'w' ) as file_out : self . _writers . get ( file_extension )() . save ( out_dict , file_out ) # yaml.dump(out_dict, file_out, default_flow_style=False) except OSError : print ( 'Not a valid file path to write to: {}' . format ( fid )) @staticmethod def _clean_up_values ( payload , extra_info , file_extension ): \"\"\"Clean up the config payload so it can be written to file *Args*: payload: dirty payload extra_info: boolean to add extra info file_extension: type of file to write *Returns*: clean_dict: cleaned output payload \"\"\" out_dict = {} for key , val in vars ( payload ) . items (): # Append comment tag to the base class and convert the spock class to a dict if file_extension == '.json' : out_dict . update ({ key : asdict ( val )}) else : out_dict . update ({( '# ' + key ): asdict ( val )}) # Convert values clean_dict = {} for key , val in out_dict . items (): clean_inner_dict = {} for inner_key , inner_val in val . items (): # Convert tuples to lists so they get written correctly if type ( inner_val ) == tuple : clean_inner_dict . update ({ inner_key : list ( inner_val )}) elif inner_val is not None : clean_inner_dict . update ({ inner_key : inner_val }) clean_dict . update ({ key : clean_inner_dict }) if extra_info : clean_dict = add_info ( clean_dict ) return clean_dict","title":"Module spock.saver"},{"location":"reference/spock/saver/#classes","text":"","title":"Classes"},{"location":"reference/spock/saver/#saver","text":"class Saver ( ) Base class for saving configs Contains methods to build a correct output payload and then writes to file based on the file extension Attributes : _writers : maps file extension to the correct i / o handler View Source class Saver : \"\"\"Base class for saving configs Contains methods to build a correct output payload and then writes to file based on the file extension *Attributes*: _writers: maps file extension to the correct i/o handler \"\"\" def __init__ ( self ) : self . _writers = { '.yaml' : YAMLHandler , '.toml' : TOMLHandler , '.json' : JSONHandler } def __call__ ( self , * args , ** kwargs ) : return Saver () def save ( self , payload , path , create_save_path = False , extra_info = True , file_extension = '.yaml' ) : #pylint : disable = too - many - arguments \"\"\"Writes Spock config to file Cleans and builds an output payload and then correctly writes it to file based on the specified file extension *Args*: payload: current config payload path: path to save create_save_path: boolean to create the path if non-existent extra_info: boolean to write extra info file_extension: what type of file to write *Returns*: None \"\"\" supported_extensions = list ( self . _writers . keys ()) if file_extension not in list ( self . _writers . keys ()) : raise ValueError ( f 'Invalid fileout extension. Expected a fileout from {supported_extensions}' ) # Make the filename name = str ( uuid1 ()) + '.spck.cfg' + file_extension fid = path / name # Fix up values out_dict = self . _clean_up_values ( payload , extra_info , file_extension ) try : if not os . path . exists ( path ) and create_save_path : os . makedirs ( path ) with open ( fid , 'w' ) as file_out : self . _writers . get ( file_extension )(). save ( out_dict , file_out ) # yaml . dump ( out_dict , file_out , default_flow_style = False ) except OSError : print ( 'Not a valid file path to write to: {}' . format ( fid )) @staticmethod def _clean_up_values ( payload , extra_info , file_extension ) : \"\"\"Clean up the config payload so it can be written to file *Args*: payload: dirty payload extra_info: boolean to add extra info file_extension: type of file to write *Returns*: clean_dict: cleaned output payload \"\"\" out_dict = {} for key , val in vars ( payload ). items () : # Append comment tag to the base class and convert the spock class to a dict if file_extension == '.json' : out_dict . update ( { key : asdict ( val ) } ) else : out_dict . update ( { ( '# ' + key ) : asdict ( val ) } ) # Convert values clean_dict = {} for key , val in out_dict . items () : clean_inner_dict = {} for inner_key , inner_val in val . items () : # Convert tuples to lists so they get written correctly if type ( inner_val ) == tuple : clean_inner_dict . update ( { inner_key : list ( inner_val ) } ) elif inner_val is not None : clean_inner_dict . update ( { inner_key : inner_val } ) clean_dict . update ( { key : clean_inner_dict } ) if extra_info : clean_dict = add_info ( clean_dict ) return clean_dict","title":"Saver"},{"location":"reference/spock/saver/#methods","text":"","title":"Methods"},{"location":"reference/spock/saver/#save","text":"def save ( self , payload , path , create_save_path = False , extra_info = True , file_extension = '.yaml' ) Writes Spock config to file Cleans and builds an output payload and then correctly writes it to file based on the specified file extension Args : payload : current config payload path : path to save create_save_path : boolean to create the path if non - existent extra_info : boolean to write extra info file_extension : what type of file to write Returns : None View Source def save ( self , payload , path , create_save_path = False , extra_info = True , file_extension = '.yaml' ): # pylint : disable = too - many - arguments \"\"\"Writes Spock config to file Cleans and builds an output payload and then correctly writes it to file based on the specified file extension *Args*: payload: current config payload path: path to save create_save_path: boolean to create the path if non-existent extra_info: boolean to write extra info file_extension: what type of file to write *Returns*: None \"\"\" supported_extensions = list ( self . _writers . keys ()) if file_extension not in list ( self . _writers . keys ()): raise ValueError ( f 'Invalid fileout extension. Expected a fileout from {supported_extensions}' ) # Make the filename name = str ( uuid1 ()) + '.spck.cfg' + file_extension fid = path / name # Fix up values out_dict = self . _clean_up_values ( payload , extra_info , file_extension ) try : if not os . path . exists ( path ) and create_save_path : os . makedirs ( path ) with open ( fid , 'w' ) as file_out : self . _writers . get ( file_extension )(). save ( out_dict , file_out ) # yaml . dump ( out_dict , file_out , default_flow_style = False ) except OSError : print ( 'Not a valid file path to write to: {}' . format ( fid ))","title":"save"},{"location":"reference/spock/utils/","text":"Module spock.utils Utility functions for Spock View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Utility functions for Spock\"\"\" from copy import copy import os from time import localtime from time import strftime from typing import List from typing import Tuple import git from spock._dataclasses import field def add_info ( out_dict ): \"\"\"Adds extra information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" out_dict = add_date_info ( out_dict ) out_dict = add_repo_info ( out_dict ) return out_dict def add_repo_info ( out_dict ): \"\"\"Adds GIT information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" try : # Assume we are working out of a repo repo = git . Repo ( os . getcwd ()) out_dict . update ({ '# Git BRANCH' : repo . active_branch . name }) out_dict . update ({ '# Git COMMIT SHA' : repo . head . object . hexsha }) if len ( repo . untracked_files ) > 0 or len ( repo . head . commit . diff ( None )) > 0 : git_status = 'DIRTY' else : git_status = 'CLEAN' out_dict . update ({ '# Git STATUS' : git_status }) out_dict . update ({ '# Git ORIGIN' : repo . remotes . origin . url }) except git . InvalidGitRepositoryError : # But it's okay if we are not for key in ( 'BRANCH' , 'COMMIT SHA' , 'STATUS' , 'ORIGIN' ): out_dict . update ({ f '# Git {key}' : 'UNKNOWN' }) return out_dict def add_date_info ( out_dict ): \"\"\"Adds date information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" out_dict . update ({ '# Run Date' : strftime ( '%Y_%m_ %d _%H_%M_%S' , localtime ())}) return out_dict def cast ( x ): \"\"\"Recasts lists as tuples *Args*: x: object *Returns*: x: object or object recast as Tuple \"\"\" if isinstance ( x , list ): x = tuple ( x ) return x def _def_list ( values : List ): \"\"\"Creates a list of default values for List datatype that is mutable *Args*: values: default list Returns: list built from default factory \"\"\" return field ( default_factory = lambda : copy ( values )) def _def_tuple ( values : Tuple ): \"\"\"Creates a tuple of default values for Tuple datatype that is mutable *Args*: values: default tuple Returns: tuple built from default factory \"\"\" return field ( default_factory = lambda : copy ( values )) Functions add_date_info def add_date_info ( out_dict ) Adds date information to the output dictionary Args : out_dict : output dictionary Returns : out_dict : output dictionary View Source def add_date_info ( out_dict ): \"\"\"Adds date information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" out_dict . update ( { '# Run Date' : strftime ( '%Y_%m_%d_%H_%M_%S' , localtime ()) } ) return out_dict add_info def add_info ( out_dict ) Adds extra information to the output dictionary Args : out_dict : output dictionary Returns : out_dict : output dictionary View Source def add_info ( out_dict ): \"\"\"Adds extra information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" out_dict = add_date_info ( out_dict ) out_dict = add_repo_info ( out_dict ) return out_dict add_repo_info def add_repo_info ( out_dict ) Adds GIT information to the output dictionary Args : out_dict : output dictionary Returns : out_dict : output dictionary View Source def add_repo_info ( out_dict ): \"\"\"Adds GIT information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" try : # Assume we are working out of a repo repo = git . Repo ( os . getcwd ()) out_dict . update ( { '# Git BRANCH' : repo . active_branch . name } ) out_dict . update ( { '# Git COMMIT SHA' : repo . head . object . hexsha } ) if len ( repo . untracked_files ) > 0 or len ( repo . head . commit . diff ( None )) > 0 : git_status = 'DIRTY' else : git_status = 'CLEAN' out_dict . update ( { '# Git STATUS' : git_status } ) out_dict . update ( { '# Git ORIGIN' : repo . remotes . origin . url } ) except git . InvalidGitRepositoryError : # But it 's okay if we are not for key in (' BRANCH ', ' COMMIT SHA ', ' STATUS ', ' ORIGIN '): out_dict.update({f' # Git { key } ': ' UNKNOWN '} ) return out_dict cast def cast ( x ) Recasts lists as tuples Args : x : object Returns : x : object or object recast as Tuple View Source def cast ( x ): \"\"\"Recasts lists as tuples *Args*: x: object *Returns*: x: object or object recast as Tuple \"\"\" if isinstance ( x , list ): x = tuple ( x ) return x","title":"Utils"},{"location":"reference/spock/utils/#module-spockutils","text":"Utility functions for Spock View Source # -*- coding: utf-8 -*- # Copyright 2019 FMR LLC <opensource@fidelity.com> # SPDX-License-Identifier: Apache-2.0 \"\"\"Utility functions for Spock\"\"\" from copy import copy import os from time import localtime from time import strftime from typing import List from typing import Tuple import git from spock._dataclasses import field def add_info ( out_dict ): \"\"\"Adds extra information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" out_dict = add_date_info ( out_dict ) out_dict = add_repo_info ( out_dict ) return out_dict def add_repo_info ( out_dict ): \"\"\"Adds GIT information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" try : # Assume we are working out of a repo repo = git . Repo ( os . getcwd ()) out_dict . update ({ '# Git BRANCH' : repo . active_branch . name }) out_dict . update ({ '# Git COMMIT SHA' : repo . head . object . hexsha }) if len ( repo . untracked_files ) > 0 or len ( repo . head . commit . diff ( None )) > 0 : git_status = 'DIRTY' else : git_status = 'CLEAN' out_dict . update ({ '# Git STATUS' : git_status }) out_dict . update ({ '# Git ORIGIN' : repo . remotes . origin . url }) except git . InvalidGitRepositoryError : # But it's okay if we are not for key in ( 'BRANCH' , 'COMMIT SHA' , 'STATUS' , 'ORIGIN' ): out_dict . update ({ f '# Git {key}' : 'UNKNOWN' }) return out_dict def add_date_info ( out_dict ): \"\"\"Adds date information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" out_dict . update ({ '# Run Date' : strftime ( '%Y_%m_ %d _%H_%M_%S' , localtime ())}) return out_dict def cast ( x ): \"\"\"Recasts lists as tuples *Args*: x: object *Returns*: x: object or object recast as Tuple \"\"\" if isinstance ( x , list ): x = tuple ( x ) return x def _def_list ( values : List ): \"\"\"Creates a list of default values for List datatype that is mutable *Args*: values: default list Returns: list built from default factory \"\"\" return field ( default_factory = lambda : copy ( values )) def _def_tuple ( values : Tuple ): \"\"\"Creates a tuple of default values for Tuple datatype that is mutable *Args*: values: default tuple Returns: tuple built from default factory \"\"\" return field ( default_factory = lambda : copy ( values ))","title":"Module spock.utils"},{"location":"reference/spock/utils/#functions","text":"","title":"Functions"},{"location":"reference/spock/utils/#add_date_info","text":"def add_date_info ( out_dict ) Adds date information to the output dictionary Args : out_dict : output dictionary Returns : out_dict : output dictionary View Source def add_date_info ( out_dict ): \"\"\"Adds date information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" out_dict . update ( { '# Run Date' : strftime ( '%Y_%m_%d_%H_%M_%S' , localtime ()) } ) return out_dict","title":"add_date_info"},{"location":"reference/spock/utils/#add_info","text":"def add_info ( out_dict ) Adds extra information to the output dictionary Args : out_dict : output dictionary Returns : out_dict : output dictionary View Source def add_info ( out_dict ): \"\"\"Adds extra information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" out_dict = add_date_info ( out_dict ) out_dict = add_repo_info ( out_dict ) return out_dict","title":"add_info"},{"location":"reference/spock/utils/#add_repo_info","text":"def add_repo_info ( out_dict ) Adds GIT information to the output dictionary Args : out_dict : output dictionary Returns : out_dict : output dictionary View Source def add_repo_info ( out_dict ): \"\"\"Adds GIT information to the output dictionary *Args*: out_dict: output dictionary *Returns*: out_dict: output dictionary \"\"\" try : # Assume we are working out of a repo repo = git . Repo ( os . getcwd ()) out_dict . update ( { '# Git BRANCH' : repo . active_branch . name } ) out_dict . update ( { '# Git COMMIT SHA' : repo . head . object . hexsha } ) if len ( repo . untracked_files ) > 0 or len ( repo . head . commit . diff ( None )) > 0 : git_status = 'DIRTY' else : git_status = 'CLEAN' out_dict . update ( { '# Git STATUS' : git_status } ) out_dict . update ( { '# Git ORIGIN' : repo . remotes . origin . url } ) except git . InvalidGitRepositoryError : # But it 's okay if we are not for key in (' BRANCH ', ' COMMIT SHA ', ' STATUS ', ' ORIGIN '): out_dict.update({f' # Git { key } ': ' UNKNOWN '} ) return out_dict","title":"add_repo_info"},{"location":"reference/spock/utils/#cast","text":"def cast ( x ) Recasts lists as tuples Args : x : object Returns : x : object or object recast as Tuple View Source def cast ( x ): \"\"\"Recasts lists as tuples *Args*: x: object *Returns*: x: object or object recast as Tuple \"\"\" if isinstance ( x , list ): x = tuple ( x ) return x","title":"cast"}]}